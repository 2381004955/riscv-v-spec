= RISC-V "V" Vector Extension
Version 0.7-draft-20190107
:doctype: article
:encoding: utf-8
:lang: en
:toc: left
:numbered:
:stem: latexmath

== Introduction

This document describes the draft of the RISC-V base vector extension.
The document describes all the individual features of the base vector
extension.

NOTE: This is a draft of a stable proposal for the vector
specification to be used for implementation and evaluation.  This
version is intended to be stable enough to begin developing detailed
encoding, toolchains, functional simulators, and initial
implementations.

The term _base_ _vector_ _extension_ is used informally to describe
the standard set of vector ISA components.  The base vector extension
can expected to be used in the standard Unix platform profile that
supports vectors.  Other platforms, including embedded platforms, may
choose to implement subsets of these extensions as described below.

NOTE: Each actual platform profile will formally specify the mandatory
components of any vector extension adopted by that platform.

The base vector extension is designed to act as a base for additional
vector extensions in various domains, including cryptography and
machine learning.

== Implementation-defined constant parameters

Each hart supporting the vector extension defines two parameters.

The maximum size of a single vector element in bits, _ELEN_, which
must be a power of 2.

The number of bits in a vector register, _VLEN_ >= _ELEN_, which must
be a power of 2.

NOTE: Platform profiles may set further constraints on these
parameters, for example, requiring that ELEN >= max(XLEN,FLEN) or
requiring a minimum VLEN value.

The ISA supports writing binary code that under certain constraints
will execute portably on harts with different values for these
parameters.

NOTE: Code can be written that will expose differences in
implementation parameters.

NOTE: Thread contexts with active vector state cannot be migrated
during execution between harts that have different VLEN and ELEN
parameters.

== Vector Extension Programmer's Model

The vector extension adds 32 vector registers, and four unprivileged
CSRs (`vtype`, `vxsat`, `vxrm`, `vl`) to a base scalar RISC-V
ISA.  If the base scalar ISA does not include floating-point, then a
`fcsr` register is also added to hold mirrors of the `vxsat` and
`vxrm` CSRs as explained below.

[source]
----
New vector CSRs

Address  Privilege Name   Description
0x008    URW       vtype  Vector data type register
0x009    URW       vxsat  Fixed-Point Saturate Flag
0x00A    URW       vxrm   Fixed-Point Rounding Mode
0xC20    URO       vl     Vector length
----

=== Vector Registers

The vector extension adds 32 architectural vector registers,
`v0`-`v31` to the base scalar RISC-V ISA.

Each vector register has a fixed VLEN bits of state.

NOTE: Zfinx ("F in X") is a new ISA option under consideration where
floating-point instructions take their arguments from the integer
register file.  The 0.7 vector extension is also compatible with this
option.

=== Vector type register, `vtype`

The XLEN-wide _vector_ _type_ CSR, `vtype` provides the default type
used to interpret the contents of the vector register file. The vector
type also determines the organization of elements in each vector
register, and how multiple vector registers are grouped.

The `type` register has two fields, `vsew[2:0]`, and
`vlmul`.

[source]
----
vtype layout

    bits    contents
XLEN-1:9    Reserved (write 0)
     8:2    vsew[5:0]
     1:0    vlmul[1:0]
----

NOTE: The smallest base implementation has only four bits in `vtype`,
two bits for `vsew[1:0]` and two bits for `vlmul[1:0]`.

NOTE: Further standard and custom extensions to the vector base will
extend these fields to support a greater variety of data types.

NOTE: An extended instruction encoding length would allow these fields
to be specified in the instruction encoding, though `vlmul` might want
to be varied with AVL.

==== Vector standard element width `vsew`

The value in `vsew` sets the dynamic _standard_ _element_ _width_
(SEW).  By default, a vector register is viewed as being divided into
VLEN / SEW standard-width elements.  In the base vector extension,
only SEW up to max(XLEN,FLEN) are required to be supported.

[source]
----
  vsew[5:0] (standard element width) encoding

  vsew[5:0]  SEW
  ---        ----
  000000        8
  000001       16
  000010       32
  000011       64
  000100      128
  000101      256
  000110      512
  000111     1024
  xxx???     reserved xxx!=0
----

[source]
----
  Example VLEN = 128 bits

  SEW  Elements per vector register
   64     2
   32     4
   16     8
    8    16
----

==== Vector register grouping and `vlmul` field

Multiple vector registers can be grouped together to form a _vector_
_register_ _group_, so that a single vector instruction can operate on
multiple vector registers.  Vector register groups allow double-width
or larger elements to be operated on with the same vector length as
standard-width elements.  Vector register groups also provide greater
execution efficiency for longer vectors.

The number of vector registers in a group, _LMUL_, is an integer power
of two set by the `vlmul` field in `vtype`.  The maximum vector length
possible in a single vector instruction, VLMAX, is then increased by
a factor of LMUL.

[source]
----
 vlmul  LMUL  #groups   VLMAX        Grouped registers
 00       1       32      VLEN/SEW   vn (no group)
 01       2       16    2*VLEN/SEW   vn, vn+1
 10       4        8    4*VLEN/SEW   vn, ..., vn+3
 11       8        4    8*VLEN/SEW   vn, ..., vn+7
----

When `vlmul=01`, then vector operations on register ``v``__n__ also
operate on vector register``v``__n__+1, giving twice the vector length
in bits.  Instructions specifying a vector operand with an
odd-numbered vector register will raise an illegal instruction
exception.

Similarly, when `vlmul=10`, every vector operation operates on four
vector registers at a time, and instructions specifying vector
operands using vector register numbers that are not multiples of four
will raise an illegal instruction exception.  When `vlmul=11`,
operations operate on eight vector registers at a time, and
instructions specifying vector operands using register numbers that
are not multiples of eight will raise an illegal instruction
exception.

NOTE: Scalar operands, described below, can come from any vector
register regardless of the `vlmul` setting.

=== Vector Length Register `vl`

The _XLEN_-bit-wide read-only `vl` CSR can only be updated by the
`vsetvli` and `vsetvl` instructions.

The `vl` register holds an unsigned integer specifying the number of
elements to be updated by a vector instruction.  Elements in the
destination vector with indices >= `vl` are zeroed during
execution of a vector instruction.  As a special case, when `vl`=0,
no elements are updated in the destination vector.

NOTE: The number of bits implemented in `vl` depends on the
implementation's maximum vector length of the smallest supported
type. The smallest vector implementation, RV32IV, would need at least
three bits in `vl` to hold the values 0, 1, 2, 3, 4.

=== Vector Fixed-Point Rounding Mode Register `vxrm`

The vector fixed-point rounding-mode register holds a two-bit
read-write rounding-mode field.  The vector fixed-point rounding-mode
is given a separate CSR address to allow independent access, but is
also reflected as a field in the upper bits of `fcsr`.  Systems
without floating-point must add `fcsr` when adding the vector
extension.

[source]
----
vxrm holds fixed-point rounding mode.

Bits   Abbreviation  Rounding Mode
[1:0]
 00    rnu           round-to-nearest-up (add +0.5 LSB)
 01    rne           round-to-nearest-even
 10    rdn           round-down (truncate)
 11    rod           round-to-odd (OR bits into LSB, aka "jam")

Bits[XLEN-1:2] should be written as zeros.
----

NOTE: The rounding mode can be set with a single `csrwi` instruction.

=== Vector Fixed-Point Saturation Flag `vxsat`

The `vxsat` CSR holds a single read-write bit that indicates if a
fixed-point instruction has had to saturate an output value to fit
into a destination format.

The `vxsat` bit is reflected in the upper bits of `fcsr`.

=== Vector Fixed-Point Fields in `fcsr`

The `vxrm` and `vxsat` separate CSRs can also be accessed via fields
in the floating-point CSR, `fcsr`.  The `fcsr` register must be added
to systems without floating-point that add a vector extension.


[source]
----
fcsr layout

Bits    Name    Description
10:9    vxrm    Fixed-point rounding mode
   8    vxsat   Fixed-point saturation flag
 7:5    frm     Floating-point rounding mode
 4:0    fflags  Floating-point accrued exception flags
----

NOTE: The fields are packed into `fcsr` to make context-save/restore
faster.

== Mapping of vector elements to vector register state

The following diagrams illustrate how different width elements are
packed into the bytes of a vector register depending on the current
SEW and LMUL settings, as well as implementation ELEN and VLEN.
Elements are packed into each vector register with the
least-significant byte in the lowest-numbered bits.

NOTE: Previous RISC-V vector proposals (< 0.6) hid this mapping from
software, whereas this proposal has a specific mapping for all
configurations, which reduces implementation flexibilty but removes
need for zeroing on config changes.  Making the mapping explicit also
has the advantage of simplifying oblivious context save-restore code,
as the code can save the configuration in `vl` and `vtype`,
then reset `vtype` to a convenient value (e.g., four vector groups of
LMUL=8, SEW=ELEN) before saving all vector register bits without
needing to parse the configuration.  The reverse process will restore
the state.

=== Mapping with LMUL=1

When LMUL=1, elements are simply packed in order from the
least-significant to most-significant bits of the vector register.

NOTE: To increase readability, vector register layouts are drawn with
bytes ordered from right to left with increasing byte address.  Bits
within an element are numbered in a little-endian format with
increasing bit index from right to left corresponding to increasing
magnitude.

[source]
----
  The element index is given in hexadecimal and is shown placed at the least-significant byte of the stored element. ELEN <=128 and LMUL=1 throughout.


 VLEN=32b

 Byte         3 2 1 0

 SEW=8b       3 2 1 0
 SEW=16b        1   0
 SEW=32b            0

 VLEN=64b

 Byte        7 6 5 4 3 2 1 0

 SEW=8b      7 6 5 4 3 2 1 0
 SEW=16b       3   2   1   0
 SEW=32b           1       0
 SEW=64b                   0

 VLEN=128b

 Byte        F E D C B A 9 8 7 6 5 4 3 2 1 0

 SEW=8b      F E D C B A 9 8 7 6 5 4 3 2 1 0
 SEW=16b       7   6   5   4   3   2   1   0
 SEW=32b           3       2       1       0
 SEW=64b                   1               0
 SEW=128b                                  0

 VLEN=256b

 Byte     1F1E1D1C1B1A19181716151413121110 F E D C B A 9 8 7 6 5 4 3 2 1 0

 SEW=8b   1F1E1D1C1B1A19181716151413121110 F E D C B A 9 8 7 6 5 4 3 2 1 0
 SEW=16b     F   E   D   C   B   A   9   8   7   6   5   4   3   2   1   0
 SEW=32b         7       6       5       4       3       2       1       0
 SEW=64b                 3               2               1               0
 SEW=128b                                1                               0
----

=== Mapping with LMUL > 1

When vector registers are grouped, the elements of the vector register
group are striped across the constituent vector registers.

When VLEN > 128 and SEW =< 128, the striping pattern is repeated in
multiples of 128 bits.  The first 128/SEW elements are packed
contiguously at the start of the first vector register in the group.
The next 128/SEW elements are packed contiguously at the start of the
next vector register in the group.  After packing the first
LMUL*128/SEW elements at the start of each of the LMUL vector
registers in the group, the second LMUL*128/SEW group of elements are
packed into the second 128b segment of each of the vector registers in
the group, and so on.

[source]
----
 Example 1: VLEN=32b, SEW=16b, LMUL=2

 Byte         3 2 1 0
 v2*n           1   0
 v2*n+1         3   2

 Example 2: VLEN=64b, SEW=32b, LMUL=2

 Byte         7 6 5 4 3 2 1 0
 v2*n               1       0
 v2*n+1             3       2

 Example 3: VLEN=128b, SEW=32b, LMUL=2

 Byte        F E D C B A 9 8 7 6 5 4 3 2 1 0
 v2*n              3       2       1       0
 v2*n+1            7       6       5       4

 Example 4: VLEN=256b, SEW=32b, LMUL=2

 Byte     1F1E1D1C1B1A19181716151413121110 F E D C B A 9 8 7 6 5 4 3 2 1 0
 v2*n            B       A       9       8       3       2       1       0
 v2*n+1          F       E       D       C       7       6       5       4
----

When SEW > 128, the striping pattern places one element in each vector
register in the group before moving to the next vector register in the
group.  So, when LMUL=2, the even-numbered vector register contains
the even-numbered elements of the vector and the odd-numbered vector
register contains the odd-numbered elements of the vector.

[source]
----
 Example: VLEN=256b, SEW=256b, LMUL=2

 Byte     1F1E1D1C1B1A19181716151413121110 F E D C B A 9 8 7 6 5 4 3 2 1 0
 v2*n                                                                    0
 v2*n+1                                                                  1

----

When LMUL = 4, four vector registers hold elements as shown:

[source]
----
 Example 1: VLEN=32b, SEW=16b, LMUL=4

 Byte         3 2 1 0
 v4*n           1   0
 v4*n+1         3   2
 v4*n+2         5   4
 v4*n+3         7   6

 Example 2: VLEN=64b, SEW=32b, LMUL=4

 Byte         7 6 5 4 3 2 1 0
 v4*n               1       0
 v4*n+1             3       2
 v4*n+2             5       4
 v4*n+3             7       6


 Example 3: VLEN=128b, SEW=32b, LMUL=4

 Byte          F E D C B A 9 8 7 6 5 4 3 2 1 0
 v4*n                3       2       1       0   32b elements
 v4*n+1              7       6       5       4
 v4*n+2              B       A       9       8
 v4*n+3              F       E       D       C

 Example 4: VLEN=256b, SEW=32b, LMUL=4

 Byte     1F1E1D1C1B1A19181716151413121110 F E D C B A 9 8 7 6 5 4 3 2 1 0
 v4*n           13      12      11      10       3       2       1       0
 v4*n+1         17      16      15      14       7       6       5       4
 v4*n+2         1B      1A      19      18       B       A       9       8
 v4*n+3         1F      1E      1D      1C       F       E       D       C

 Example 5: VLEN=256b, SEW=256b, LMUL=4

 Byte     1F1E1D1C1B1A19181716151413121110 F E D C B A 9 8 7 6 5 4 3 2 1 0
 v4*n                                                                    0
 v4*n+1                                                                  1
 v4*n+2                                                                  2
 v4*n+3                                                                  3
----

A similar pattern is followed for LMUL = 8.

[source]
----
 Example: VLEN=256b, SEW=32b, LMUL=8

 Byte   1F1E1D1C1B1A19181716151413121110 F E D C B A 9 8 7 6 5 4 3 2 1 0
 v8*n         23      22      21      20       3       2       1       0
 v8*n+1       27      26      25      24       7       6       5       4
 v8*n+2       2B      2A      29      28       B       A       9       8
 v8*n+3       2F      2E      2D      2C       F       E       D       C
 v8*n+4       33      32      31      30      13      12      11      10
 v8*n+5       37      36      35      34      17      16      15      14
 v8*n+6       3B      3A      39      38      1B      1A      19      18
 v8*n+7       3F      3E      3D      3C      1F      1E      1D      1C
----

NOTE: The striping pattern is a compromise between the datapath wiring
needed for mixed-width operations and the buffering needed to
corner-turn wide vector unit-stride memory accesses into parallel
accesses for the vector register file.  The value 128b also matches
the widest standard pointer (RV128) and floating-point types (Q).  The
previous 0.6 design optimized datapath wiring but required buffering
up to 8 element groups when accessing the vector regfile (or
alternatively using multiple narrower ports) regardless of width of
memory port.  The current 0.7 design requires mixed-width operands to
cross no more than 128b of datapath, while spatial locality of vector
regfile storage access is increased to 128b per write.  When the
unit-stride memory access width is greater than 128b, values will
still need to be buffered or wider regfile ports used.

NOTE: The previous explicit configuration design allowed these
tradeoffs to be managed at the microarchitectural level and optimized
for each configuration.

NOTE: As an alternative, the striping width (SLEN=128b) could be an
implementation-dependent parameter, for example, based on min(VLEN,
max(ELEN,128)).

=== Mapping across mixed-width operations

The pattern used to map elements within a vector register group is
designed to reduce datapath wiring when supporting operations across
multiple element widths.  The recommended software strategy in this
case is to modify `vtype` dynamically to keep SEW/LMUL constant (and
hence VLMAX constant).

The following example shows four different packed element widths (8b,
16b, 32b, 64b) in a VLEN=256b implementation.  The vector register
grouping factor (LMUL) is increased by the relative element size such
that each group can hold the same number of vector elements (32 in
this example) to simplify stripmining code.  Any operation between
elements with the same index only touches operand bits located within
the same 128b portion of the datapath.

[source]
----
 VLEN=256b
 Byte     1F1E1D1C1B1A19181716151413121110 F E D C B A 9 8 7 6 5 4 3 2 1 0

 SEW=8b, LMUL=1, VLMAX=32

 v1       1F1E1D1C1B1A19181716151413121110 F E D C B A 9 8 7 6 5 4 3 2 1 0

 SEW=16b, LMUL=2, VLMAX=32

 v2*n       17  16  15  14  13  12  11  10   7   6   5   4   3   2   1   0
 v2*n+1     1F  1E  1D  1C  1B  1A  19  18   F   E   D   C   B   A   9   8

 SEW=32b, LMUL=4, VLMAX=32

 v4*n           13      12      11      10       3       2       1       0
 v4*n+1         17      16      15      14       7       6       5       4
 v4*n+2         1B      1A      19      18       B       A       9       8
 v4*n+3         1F      1E      1D      1C       F       E       D       C

 SEW=64b, LMUL=8, VLMAX=32

 v8*n                   11              10               1               0
 v8*n+1                 13              12               3               2
 v8*n+2                 15              14               5               4
 v8*n+3                 17              16               7               6
 v8*n+4                 19              18               9               8
 v8*n+5                 1B              1A               B               A
 v8*n+6                 1D              1C               D               C
 v8*n+7                 1F              1E               F               E
----

Larger LMUL settings can also used to simply increase vector length to
reduce instruction fetch and dispatch overheads, in cases where fewer
logical vector registers are required.

Larger LMUL values can cause lower datapath utilization for short
vectors.  In the example above with VLEN=256b and LMUL=8, if the
implementation is purely spatial with a 256b-wide vector datapath,
then for an application vector length less than 17, only half of the
datapath will be active.  The `setvl` instructions below have a
facility to dynamically select an appropriate LMUL according to the
required application vector length (AVL).

[[sec-mask-register-layout]]
=== Mask register layout

A vector mask occupies only one vector register regardless of SEW and
LMUL.  The mask bits that are used for each vector operation depends
on the current SEW and LMUL setting.

The maximum number of elements in a vector operand is:

[source]
----
               VLMAX = LMUL * VLEN/SEW
----

A mask is allocated for each element by dividing the mask register
into VLEN/VLMAX fields.  The size of each mask element in bits, _MLEN_,
is:

[source]
----
                MLEN = VLEN/VLMAX
                     = VLEN/(LMUL * VLEN/SEW)
                     = SEW/LMUL
----

The size of MLEN varies from ELEN (SEW=ELEN, LMUL=1) down to 1
(SEW=8b,LMUL=8), and hence a single vector register can always hold
the entire mask register.

The mask bits for element _i_ are located in bits
[MLEN*_i_+(MLEN-1),MLEN*_i_] of the mask register.  When a mask
element is written by a compare instruction, the low bit in the mask
element holds the mask result and the upper bits of the mask element
are zeroed.  When a value is read as a mask, only the
least-significant bit of the mask element is used to control masking
and the upper bits are ignored.

The pattern is such that for constant SEW/LMUL values, the effective
predicate bits are located in the same bit of the mask vector
register, which simplifies use of masking in loops with mixed-width
elements.

[source]
----
 VLEN=32b

          Byte    3   2   1   0
 LMUL=1,SEW=8b
                  3   2   1   0  Element
                [24][16][08][00] Mask bit position in decimal

 LMUL=2,SEW=16b
                      1       0
                    [08]    [00]
                      3       2
                    [24]    [16]

 LMUL=4,SEW=32b               0
                            [00]
                              1
                            [08]
                              2
                            [16]
                              3
                            [24]
----

[source]
----
 LMUL=2,SEW=8b
                  3   2   1   0
                [12][08][04][00]
                  7   6   5   4
                [28][24][20][16]

 LMUL=8,SEW=32b
                              0
                            [00]
                              1
                            [04]
                              2
                            [08]
                              3
                            [12]
                              4
                            [16]
                              5
                            [20]
                              6
                            [24]
                              7
                            [28]

 LMUL=8,SEW=8b
                  3   2   1   0
                [03][02][01][00]
                  7   6   5   4
                [07][06][05][04]
                  B   A   9   8
                [11][10][09][08]
                  F   E   D   C
                [15][14][13][12]
                 13  12  11  10
                [19][18][17][16]
                 17  16  15  14
                [23][22][21][20]
                 1B  1A  19  18
                [27][26][25][24]
                 1F  1E  1D  1C
                [31][30][29][28]
----

[source]
----
 VLEN=256b
 Byte     1F1E1D1C1B1A19181716151413121110 F E D C B A 9 8 7 6 5 4 3 2 1 0

 SEW=8b, LMUL=1, VLMAX=32

 v1       1F1E1D1C1B1A19181716151413121110 F E D C B A 9 8 7 6 5 4 3 2 1 0
        [248]          ...            [128] ...[96] ...[64] ...[32] ... [0] Mask bit positions in decimal

 SEW=16b, LMUL=2, VLMAX=32

 v2*n       17  16  15  14  13  12  11  10   7   6   5   4   3   2   1   0
          [184]          ...          [128]    ...     [32]    ...      [0]
 v2*n+1     1F  1E  1D  1C  1B  1A  19  18   F   E   D   C   B   A   9   8
          [248]          ...          [196]    ...     [96]    ...     [64]

 SEW=32b, LMUL=4, VLMAX=32

 v4*n           13      12      11      10       3       2       1       0
              [152]        ...        [128]    [24]        ...          [0]
 v4*n+1         17      16      15      14       7       6       5       4
              [184]        ...        [160]    [56]        ...         [32]
 v4*n+2         1B      1A      19      18       B       A       9       8
              [116]        ...        [192]    [88]        ...         [64]
 v4*n+3         1F      1E      1D      1C       F       E       D       C
              [248]        ...        [224]   [120]        ...         [96]

 SEW=64b, LMUL=8, VLMAX=32

 v8*n                   11              10               1               0
                      [136]           [128]             [8]             [0]
 v8*n+1                 13              12               3               2
                      [152]           [144]            [24]            [16]
 v8*n+2                 15              14               5               4
                      [168]           [160]            [40]            [32]
 v8*n+3                 17              16               7               6
                      [184]           [176]            [56]            [48]
 v8*n+4                 19              18               9               8
                      [200]           [192]            [72]            [64]
 v8*n+5                 1B              1A               B               A
                      [216]           [208]            [88]            [80]
 v8*n+6                 1D              1C               D               C
                      [232]           [224]           [104]            [96]
 v8*n+7                 1F              1E               F               E
                      [248]           [240]           [120]           [112]
----

== Configuration-setting instructions

A set of instructions are provided to allow rapid configuration of the
values in `vl` and `vtype` to match application needs.

=== `vsetvli`/`vsetvl` instructions

----
 vsetvli rd, rs1, vtypei # rd = new vl, rs1 = AVL, vtypei = new vtype setting
                         # if rs1 = x0, then use maximum vector length
 vsetvl  rd, rs1, rs2    # rd = new vl, rs1 = AVL, rs2 = new vtype value
                         # if rs1 = x0, then use maximum vector length
----

The `vsetvli` instruction sets the `vtype` and `vl` CSRs based on its
arguments, and writes the new value of `vl` into `rd`.

The new `vtype` setting is encoded in the immediate field `vtypei` for
`vsetvli` and in the `rs2` register for `vsetvl`.

[source]
----
 Suggested assembler names used for vtypei setting

 vint8    #   8b signed integers
 vint16   #  16b signed integers
 vint32   #  32b signed integers
 vint64   #  64b signed integers
 vint128  # 128b signed integers

 vfp16    #  16b IEEE FP
 vfp32    #  32b IEEE FP
 vfp64    #  64b IEEE FP
 vfp128   # 128b IEEE FP

 vlmul1   # Vlmul x1
 vlmul2   # Vlmul x2
 vlmul4   # Vlmul x4
 vlmul8   # Vlmul x8

 vlmul1max   # Vlmul x1 max
 vlmul2max   # Vlmul x2 max
 vlmul4max   # Vlmul x4 max
 vlmul8max   # Vlmul x8 max
----

NOTE: The immediate argument `vtypei` can be a compressed form of the
full vtype setting, capturing the most common use cases.  For the base
proposed here, it is assumed that at least four bits of immediate are
available to write all standard values of `vtype` (`vsew[2:0]` and
`vlmul`).

The `vtype` setting must be supported by the implementation, and the
 `vsetvl{i}` instructions will raise an illegal instruction exception
 if the setting is not supported.

NOTE: Specifing that `vtype` is WARL is problematic as that would hide
errors.  The current spec is problematic in that it requires a trap
based on a data value in a CSR write. It would simplify pipelines if
`vtype` value errors were flagged at use not write, but somehow need
to catch errant code without requiring full XLEN bits in `vtype` when
only a few bits are actually used. One alternative is to allow
substitution of a fixed illegal value in `vtype`, e.g., all 1s, if an
attempt is made to write an unsupported value.  This would then cause
a trap on use.

The requested application vector length (AVL) is passed in `rs1` as an
unsigned integer.

Can use `vsetvl` with AVL=x0 to read current VLMAX, though this does
overwrite `vl`.

=== Constraints on setting `vl`

The resulting `vl` setting must satisfy the following constraints:

. `vl = AVL` if `AVL \<= VLMAX`
. `vl >= ceil(AVL / 2)` if `AVL < (2 * VLMAX)`
. `vl = VLMAX` if `AVL >= (2 * VLMAX)`
. Deterministic on any given implementation for same input AVL and `vtype` values
. These specific properties follow from the prior rules:
.. `vl = 0` if  `AVL = 0`
.. `vl > 0` if `AVL > 0`
.. `vl \<= VLMAX`
.. `vl \<= AVL`


[NOTE]
--
The `vl` setting rules are designed to be sufficiently strict to
preserve `vl` behavior across register spills and context swaps for
`AVL \<= VLMAX`, yet flexible enough to enable implementations to improve
vector lane utilization for `AVL > VLMAX`.

For example, this permits an implementation to set `vl = ceil(AVL / 2)`
for `VLMAX < AVL < 2*VLMAX` in order to evenly distribute work over the
last two iterations of a stripmine loop.
Requirement 2 ensures that the first stripmine iteration of reduction
loops uses the largest vector length of all iterations, even in the case
of `AVL < 2*VLMAX`.
This allows software to avoid needing to explicitly calculate a running
maximum of vector lengths observed during a stripmined loop.
--

=== Rules for vlmul

Due to the striping of elements across multiple vector registers,
shorter AVLs can give low datapath utilization with large LMUL.
Ideally, LMUL should be chosen to be no longer than necessary to
accomodate the desired AVL.  The `vlmul` parameter can optionally be
supplied as a maximum value `vlmulmax`, in which case the following
rules are used to set `vlmul`.

[source]
----
Rule for setting LMUL based on vlmulmax value

VLMAX1 = VLEN/SEW     # Elements fitting in one vector register

       0 < AVL <= VLMAX1,   LMUL = 1                # Don't group
VLMAX1   < AVL <= VLMAX1*2, LMUL = min(2,vlmulmax)  # Pairs
VLMAX1*2 < AVL <= VLMAX1*4, LMUL = min(4,vlmulmax)  # Quads
VLMAX1*4 < AVL              LMUL = min(8,vlmulmax)  # Octa

----

Software sets `vlmulmax` according to how many register groups are
used by the code.  Software must not use any vector register numbers
that would be illegal if the largest value of `vlmulmax` is chosen for
`vlmul`.

=== `vsetvl` instruction

The `vsetvl` variant operates similary to `vsetvli` except that it
takes a `vtype` value from `rs2` and can be used for context restore,
and when the `vtypei` field is too small to hold the desired setting.

NOTE: Several active complex types can be held in different `x`
registers and swapped in as needed using `vsetvl`.

=== Examples

The SEW and LMUL settings can be changed dynamically to provide high
throughput on mixed-width operations in a single loop.

[source]
----
# Example: Load 16-bit values, widen multiply to 32b, shift 32b result
# right by 3, store 32b values.

# Loop using only widest elements:

loop:
    vsetvli a3, a0, vint32,vlmul8max   # Use only 32-bit elements
    vlh.v v8, (a1)          # Sign-extend 16b load values to 32b elements
      sll t1, a3, 1
      add a1, a1, t1        # Bump pointer
    vmul.vs  v8, v8, v1     # 32b multiply result
    vsrl.vi  v8, v8, 3      # Shift elements
    vsw.v v8, (a2)          # Store vector of 32b results
      sll t1, a3, 2
      add a2, a2, t1        # Bump pointer
      sub a0, a0, a3        # Decrement count
      bnez a0, loop         # Any more?

# Alternative loop that switches element widths.

loop:
    vsetvli a3, a0, vint16,vlmul4  # vtype = 16-bit integer vectors
    vlh.v v4, (a1)          # Get 16b vector
      slli t1, a3, 1
      add a1, a1, t1        # Bump pointer
    vwmul.vs v8, v4, v1     # 32b in <v8--v15>

    vsetvli x0, a0, vint32,vlmul8  # Operate on 32b values
    vsrl.vi v8, v8, 3
    vsw.v v8, (a2)          # Store vector of 32b
      slli t1, t1, 2
      add a2, a2, t1        # Bump pointer
      sub a0, a0, a3        # Decrement count
      bnez a0, loop         # Any more?
----

The second loop is more complex but will have greater performance on
machines where 16b widening multiplies are faster than 32b integer
multiplies, and where 16b vector load can run faster due to the
narrower writes to the vector regfile.

NOTE: The `vlmul8max` version is used in the single-width loop to
reduce LMUL for shorter application vector lengths.  The mixed-width
loop has to use a fixed SEW=16/LMULMAX=4 and the SEW=32/LMULMAX=8
settings to the `vsetvli` instructions to obtain correct results.  If
the `vlmul?max` versions were used, the two different element widths
could have the same LMUL=1 for short vector lengths, and the elements
within the vector registers would not line up correctly.

NOTE: It should be possible to specify a different form of vlmulmax
that specifies the range of element widths to be used in overall loop
to set LMUL correctly. TBD.

== Vector instruction formats

Vector instructions can have scalar or vector source operands and
produce scalar or vector results, and most vector instructions can be
performed conditionally under a mask.

Vector loads and stores move bit patterns between vector register
elements and memory.  Vector arithmetic instructions operate on values
held in vector register elements.

=== Scalar operands

Scalar operands can be immediates, or taken from the `x` registers,
the `f` registers, or element 0 of a vector register.  Scalar results
are written to an `x` or `f` register or to element 0 of a vector
register.  Any vector register can be used to hold a scalar regardless
of the current LMUL setting.

NOTE: In a change from v0.6, the floating-point registers no longer
overlay the vector registers and scalars can now come from the integer
or floating-point registers.

=== Vector operands

Vector operands or results may occupy one or more vector registers
depending on LMUL, but are always specified using the lowest-numbered
vector register in the group.  Using other than the lowest-numbered
vector register to specify a vector register group will result in an
illegal instruction exception.

Some vector instructions consume and produce wider-width elements and
so operate on a larger vector register group than that specified in
`vlmul`.  The largest vector register group can not be greater than 8
vector registers, and if a widening vector instruction would require
greater than 8 vector registers in a group, an illegal instruction
exception is raised.

=== Vector masking

Masking is supported on many vector instructions.  Element operations
that are masked off do not modify the destination vector register
element and never generate exceptions.

In the base vector extension, the mask value is always supplied by
vector register `v0`.  Only the least-significant bit of each element
of the mask vector is used to control execution.  In the base
encoding, the mask value can be complemented before use.

NOTE: Future vector extensions may provide longer instruction
encodings with space for a full mask register specifier.

Other vector registers can be used to hold working mask values, and
regular vector logical operations can be used to perform predicate
calculations.

[[sec-vector-mask-encoding]]
==== Mask encoding

Masking is encoded in a two-bit `vm[1:0]` field (`inst[26:25]`) for all
vector instructions.

[source]
----
vm[1:0]

  00    vector result, only where v0[i].LSB = 0
  01    vector result, only where v0[i].LSB = 1
  1?    unmasked vector operations
----

NOTE: In earlier proposals, vm[1:0] was used to encode scalar
operations, but these can now be effectively obtained by setting
vector length to 1.  We may provide optimized variants of `setvl`
instructions that set vl=1 for this case.

Vector masking is represented in assembler code as another vector
operand, with `.t` or `.f` indicating if operation occurs when `v0[0]`
is `1` or `0` respectively.  If no masking operand is specified,
unmasked vector execution (`m=1?`) is assumed.

[source,asm]
----
    vop.v*    v1, v2, v3, v0.f  # enabled where v0[i].LSB=0, m=00
    vop.v*    v1, v2, v3, v0.t  # enabled where v0[i].LSB=1, m=01
    vop.v*    v1, v2, v3        # unmasked vector operation, m=1?
----

NOTE: Even though the base only supports one vector mask register
`v0`, the assembly syntax writes it out in full to be compatible with
future extensions that might add a mask register specifier.

=== Active and Tail Element Definitions

The _active_ elements during a vector instruction's execution are the
elements within the current vector length setting and where the
current mask is enabled at that element position.  The _inactive_
elements are the elements within the current vector length setting but
where the current mask is disabled at that element position.  The
_tail_ elements during a vector instruction's execution are the
elements past the current vector length setting.

[source]
----
    for element index x
    mask(x)     = unmasked || v0[x].LSB
    active(x)   = (0 <= x < vl) && mask(x)
    inactive(x) = (0 <= x < vl) && !mask(x)
    tail(x)     = (vl <= x < VLMAX)
----

All vector instructions place zeros in the tail elements of the
destination vector register group.

All vector load instructions and vector AMOs are maskable, and write
zeros to the non-active elements in the destination vector register
group, and also write zeros to the tail elements.

All maskable vector arithmetic instructions do not update the inactive
elements in the vector register, but zero the tail elements.

Some vector arithmetic instructions are not maskable, so have no
inactive elements, but still zero the tail elements.

NOTE: The inactive and tail update rules were designed to provide an
efficient compromise between requirements of implementations with and
without vector register ECC and/or renaming.  Implementations with
temporally long vector registers will be motivated to add
microarchitectural state to avoid actually writing zeros to all tail
elements, but this is a relatively simple microarchitectural
optimization.  Not updating inactive elements on a masked operation
reduces code path length for many code blocks.  Implementations with
vector register ECC or renaming will have to perform read-update-write
on the destination register value to preserve inactive elements on
arithmetic instructions, so would appear to need an extra vector
register read port.  However, the arithmetic instructions are designed
such that the largest read-port requirement is for fused multiply-add
instructions that are destructive and overwrite one source, and hence
do not need an extra read port to preserve inactive elements.  Given
that linear algebra is one of the more important applications for
vector units, and that fused multiply-add is the dominant operation in
linear algebra routines, microarchitectures will be optimized for
fused multiply-add operations and so should be able to preserve
inactive elements on other arithmetic operations without large
additional cost.  Vector load instructions are defined to zero
inactive elements to avoid the read-modify-write of the destination.
The presence of some non-maskable arithmetic instructions as well as
inactive-zeroing loads requires software to use additional vector
merge instructions to combine live values.

[source]
----
# Code using one width for predicate and different width for masked
# compute.
#   int8_t a[]; int32_t b[], c[];
#   for (i=0;  i<n; i++) { b[i] =  (a[i] < 5) ? 1 : c[i]; }
#
  loop:
    vsetvli a4, a0, vint8,vlmul1  # Byte vector for predicate calc
    vlb.v v1, (a1)                # Load a[i]
      add a1, a1, a4              # Bump pointer.
      sub a0, a0, a4              # Decrement count
    vslti.v v0, v1, 5             # a[i] < 5?

    vsetvtypei vint32,vlmul4      # Vector of 32 bit values.
    vlw.v v4, (a3), v0.f          # Load requested elements of C.
    vmerge.vi v4, v4, 1, v0.t     # Produce result.
      sll t1, a4, 2
      add a3, a3, t1              # Bump pointer.
    vsw.v v4, (a2)                # Store b[i].
      add a2, a2, t1              # Bump pointer.
      bnez a0, loop               # Any more?
----

== Vector Loads and Stores

Vector loads and stores move values between vector registers and
memory.  Vector loads and stores are masked and do not raise
exceptions on inactive elements.  Masked vector loads write zeros to
inactive elements in the destination vector register group.  Masked
vector stores do not update inactive memory elements.

=== Vector Load/Store Instruction Encoding

Vector loads and stores are encoding within the scalar floating-point
load and store major opcodes (LOAD-FP/STORE-FP).  The vector load and
store encodings repurpose a portion of the standard scalar
floating-point load/store 12-bit immediate field to provide further
vector instruction encoding, with bits[26:25] holding the standard
vector mask information (see <<sec-vector-mask-encoding>>).

[source]
----
31 30 29 27 26 25 24      20 19       15 14    12 11         7 6     0
 off | lmop | vm  |  lmopu   |    rs1    | width  |      vd    |0000111| VL*  unit-stride
 off | lmop | vm  |   rs2    |    rs1    | width  |      vd    |0000111| VLS* strided
 off | lmop | vm  |   vs2    |    rs1    | width  |      vd    |0000111| VLX* indexed
  2      3     2        5          5         3            5        7

31        27 26 25 24      20 19       15 14    12 11 10 9    7 6     0
    vs3     | vm  |  smopu   |    rs1    | width  | off | smop |0100111| VS*  unit-stride
    vs3     | vm  |   rs2    |    rs1    | width  | off | smop |0100111| VSS* strided
    vs3     | vm  |   vs2    |    rs1    | width  | off | smop |0100111| VSX* indexed
     5         2        5          5         3       2      3      7


rs1[4:0] specifies x register holding base address
rs2[4:0] specifies x register holding stride
vs2[4:0] specifies v register holding address offsets
vs3[4:0] specifies v register holding store data
vd[4:0]  specifies v register destination of load

vm[1:0] specifies vector mask
width[2:0] specifies size of memory elements, and distinguishes from FP scalar
lmop[2;0] specifies load memory addressing mode
smop[2:0] specifies store memory addressing mode
off[1:0] is a two-bit address offset field

lmopu[4:0]/smopu[4:0] are additional fields encoding variants of unit-stride instructions
----

=== Vector Load/Store Addressing Modes

The base vector extension supports unit-stride, strided, and
indexed (scatter/gather) addressing modes.  Vector load/store base
registers and strides are taken from the GPR `x` registers.

The base effective address for all vector accesses is given by adding
the contents of the `x` register named in `rs1` to the two-bit offset
scaled by the width parameter (1, 2, 4, or 8).

Vector unit-stride operations access elements stored contiguously in
memory starting from the base effective address.

Vector strided operations access the first memory element at the base
effective address, and then access subsequent elements at address
increments given by the byte offset contained in the `x` register
specified by `rs2`.

Vector indexed operations add the contents of each element of the
vector offset operand specified by `vs2` to the base effective address
to give the effective address of each element.  The vector offset
operand is treated as a vector of byte offsets.  If the vector offset
elements are narrower than XLEN, they are sign-extended to XLEN before
adding to the base effective address.  If the vector offset elements
are wider than XLEN, the least-significant XLEN bits are used in the
address calculation.

NOTE: Current PoR requires that vector byte offset and vector
read/write data are of same width.  One question is how to allow for
two sizes of vector operand in a vector indexed instruction?  E.g.,
for scatter/gather of byte values in a 64-bit address space without
requiring bytes use 64b of space in a vector register.

The vector addressing modes are encoded using the 3-bit `lmop[2:0]`
field for loads and `smop[2:0]` field for stores.

[source]
----
lmop [2:0]
   0 0 0  zero-extended unit-stride         VLxU
   0 0 1  reserved
   0 1 0  zero-extended strided             VLSxU
   0 1 1  zero-extended indexed             VLXxU
   1 0 0  sign-extended unit-stride         VLx
   1 0 1  reserved
   1 1 0  sign-extended strided             VLSx
   1 1 1  sign-extended indexed             VLXx

smop [2:0]
   0 0 0  unit-stride                       VSx
   0 0 1  reserved
   0 1 0  strided                           VSSx
   0 1 1  indexed-ordered                   VSXx
   1 0 0  reserved
   1 0 1  reserved
   1 1 0  reserved
   1 1 1  indexed-unordered                 VSXUx
----

The vector indexed memory operations have two forms, ordered and
unordered.  The indexed-unordered stores do not preserve element
ordering on stores.

NOTE: The indexed-unordered variant is provided as a potential
implementation optimization.  Implementations are free to ignore the
optimization and implement indexed-unordered identically to
indexed-ordered.

Additional unit-stride vector addressing modes are encoded using the
5-bit `lmopu` and `smopu` fields in the unit-stride load and store
instruction encodings respectively.

[source]
----
lmopu[4:0]
   00000  unit-stride
   10000  unit-stride first-fault
   yxxxx  reserved, xxxx!=0

smopu[4:0]
   00000  unit-stride
   xxxxx  reserved, xxxxx!=0
----

NOTE: A further possible unit-stride vector addressing mode would
transfer array-of-structures formats in memory into multiple
destination vector registers.  This would use the low three bits of
`*mopu` to indicate the number of memory fields in a structure from
1-8.  Different fields in the structure would be held in different
vector registers.

=== Vector Load/Store Width Encoding

The vector loads and stores are encoded using the width values that
are not claimed by the standard scalar floating-point loads and
stores.  Three of the width types encode vector loads and stores that
move fixed-size memory elements of 8 bits, 16 bits, or 32 bits, while
the fourth encoding moves SEW-bit memory elements.

[source]
----
                     Width   Mem     Reg       Offset  Opcode
                     [2:0]   bits    bits      scale

Standard scalar FP    001     16     FLEN      -       FLH/FSH
Standard scalar FP    010     32     FLEN      -       FLW/FSW
Standard scalar FP    011     64     FLEN      -       FLD/FSD
Standard scalar FP    100    128     FLEN      -       FLQ/FSQ
Vector byte           000   vl*8     vl*SEW    1       VxB
Vector halfword       101   vl*16    vl*SEW    2       VxH
Vector word           110   vl*32    vl*SEW    4       VxW
Vector element        111   vl*SEW   vl*SEW    8       VxE

Mem bits is the size of element accessed in memory
Reg bits is the size of element accessed in register

Offset scale is the amount by which the two-bit unsigned immediate
offset is multiplied to obtain a byte offset from the scalar base
register rs1.
----

Fixed-sized vector loads can optionally sign or zero-extend their
memory element into the destination register element if the register
element is wider than the memory element.  A fixed-size vector load
raises an illegal instruction exception if the destination register
element is narrower than the memory element.

Fixed-size vector stores take their operand from the least-significant
bits of the register element if the register element if wider than the
memory element.  Fixed-sized vector stores raise an illegal
instruction exception if the memory element is wider than the register
element.

The vector load/store instruction encoding includes a 2-bit unsigned
offset.  The offset is scaled according to the low two bits of the
width[2:0] field (effective offset = uoffset[4:0] * 2^width[1:0]),
such that for fixed-width elements the offset is scaled by the element
size.  For dynamic-width elements, the offset scale is fixed to 8 and
is not affected by the `vtype` setting to avoid having a dependency
between address generation and dynamic `vtype` value.  The scaled
offset is added to the scalar base register `rs1` to form the base
address of the vector memory access.

=== Vector Unit-Stride Instructions

[source,asm]
----
    # Vector unit-stride loads and stores
    # Assembler offset is written as effective byte offset, not element offset

    # vd destination, rs1 base address, vm is mask encoding (v0.t, v0.f, <missing>)
    vlb.v    vd, offset(rs1), vm # 8b signed
    vlh.v    vd, offset(rs1), vm # 16b signed
    vlw.v    vd, offset(rs1), vm # 32b signed

    vlbu.v   vd, offset(rs1), vm # 8b unsigned
    vlhu.v   vd, offset(rs1), vm # 16b unsigned
    vlwu.v   vd, offset(rs1), vm # 32b unsigned

    vle.v    vd, offset(rs1), vm # SEW

    # vs3 store data, rs1 base address, vm is mask encoding (v0.t, v0.f, <missing>)
    vsb.v     vs3, offset(rs1), vm  # 8b store
    vsh.v     vs3, offset(rs1), vm  # 16b store
    vsw.v     vs3, offset(rs1), vm  # 32b store
    vse.v     vs3, offset(rs1), vm  # SEW store
----

=== Vector Strided Instructions

[source,asm]
----
    # Vector strided loads and stores

    # vd destination, rs1 base address, rs2 byte stride
    vlsb.v    vd, offset(rs1), rs2, vm # 8b
    vlsh.v    vd, offset(rs1), rs2, vm # 16b
    vlsw.v    vd, offset(rs1), rs2, vm # 32b

    vlsbu.v    vd, offset(rs1), rs2, vm # unsigned 8b
    vlshu.v    vd, offset(rs1), rs2, vm # unsigned 16b
    vlswu.v    vd, offset(rs1), rs2, vm # unsigned 32b

    vlse.v    vd, offset(rs1), rs2, vm  # SEW

    # vs3 store data, rs1 base address, rs2 byte stride
    vssb.v    vs3, offset(rs1), rs2, vm  # 8b
    vssh.v    vs3, offset(rs1), rs2, vm  # 16b
    vssw.v    vs3, offset(rs1), rs2, vm  # 32b
    vsse.v    vs3, offset(rs1), rs2, vm  # SEW
----

=== Vector Indexed Instructions

[source,asm]
----
    # Vector indexed loads and stores

    # vd destination, rs1 base address, vs2 indices
    vlxb.v    vd, offset(rs1), vs2, vm  # 8b
    vlxh.v    vd, offset(rs1), vs2, vm  # 16b
    vlxw.v    vd, offset(rs1), vs2, vm  # 32b

    vlxbu.v    vd, offset(rs1), vs2, vm  # 8b unsigned
    vlxhu.v    vd, offset(rs1), vs2, vm  # 16b unsigned
    vlxwu.v    vd, offset(rs1), vs2, vm  # 32b unsigned

    vlxe.v    vd, offset(rs1), vs2, vm  # SEW

    # Vector ordered-indexed store instructions
    vsxb.v    vs3, offset(rs1), vs2, vm  # 8b
    vsxh.v    vs3, offset(rs1), vs2, vm  # 16b
    vsxw.v    vs3, offset(rs1), vs2, vm  # 32b
    vsxe.v    vs3, offset(rs1), vs2, vm  # SEW

    # Vector unordered-indexed store instructions
    vsuxb.v   vs3, offset(rs1), vs2, vm  # 8b
    vsuxh.v   vs3, offset(rs1), vs2, vm  # 16b
    vsuxw.v   vs3, offset(rs1), vs2, vm  # 32b
    vsuxe.v   vs3, offset(rs1), vs2, vm  # SEW
----

NOTE: Previous proposals included possibility of reverse-ordered
scatter, but common use case in vectorized memory dependence checks
can be replaced with `vamomin` operation, and vector AMOs are more
generally useful than reverse-ordered scatters.

=== Unit-stride First-Fault Loads

The unit-stride fault-first load instructions are used to vectorize
loops with data-dependent exit conditions (while loops).  These
instructions execute as a regular load except that they will only take
a trap on element 0.  If an element > 0 raises an exception, that
element and all following elements in the destination vector
register are not modified, and the vector length `vl` is reduced to the
number of elements processed without a trap.

[source,asm]
----
    vlbff.v    vd, offset(rs1), vm # 8b
    vlhff.v    vd, offset(rs1), vm # 16b
    vlwff.v    vd, offset(rs1), vm # 32b

    vlbuff.v    vd, offset(rs1), vm # unsigned 8b
    vlhuff.v    vd, offset(rs1), vm # unsigned 16b
    vlwuff.v    vd, offset(rs1), vm # unsigned 32b

    vleff.v    vd, offset(rs1), vm # SEW
----

[source]
----
strlen example using unit-stride fault-first instruction

# size_t strlen(const char *str)
# a0 holds *str

strlen:
    mv a3, a0             # Save start
loop:
    setvli a1, x0, vint8  # Vector of bytes
    vlbff.v v1, (a3)     # Get bytes
    csrr a1, vl           # Get bytes read
    add a3, a3, a1        # Bump pointer
    vseq.vi v0, v1, 0     # Set v0[i] where v1[i] = 0
    vmfirst a2, v0        # Find first set bit
    bltz a2, loop         # Not found?

    add a0, a0, a1        # Sum start + bump
    add a3, a3, a2        # Add index
    sub a0, a3, a0        # Subtract start address+bump

    ret
----

NOTE: Strided and scatter-gather fault-first instructions are not
provided as they represent a large security hole, allowing software to
check multiple random pages for accessibility without experiencing a
trap. The unit-stride versions only allow probing a region immediately
contiguous to a known region, and so do not appreciably impact
security.  It is possible that security mitigiations can be
implemented to allow first-fault variants of non-contiguous accesses
in future vector extensions.

== Vector AMO operations

NOTE: This is a tentative proposal, unclear whether this should be in
base vector extension.

Vector AMO operations are encoded using the unused width encodings
under the standard AMO major opcode.  Each active element performs an
atomic read-modify-write of a single memory location.

The `vs2` vector register supplies the memory address of each element,
while the `vs3` vector register supplies the source data.  The `vd`
register is written with the initial value of the memory element.

Vector AMOs operate as if `aq` and `rl` bits were zero on each element
with regard to ordering relative to other instructions in the same
hart.

Vector AMOs provide no ordering guarantee between element operations
in the same vector AMO instruction.

[source]
----
31        27 26 25 24      20 19       15 14    12 11       7 6     0
    vs3     | vm  |    vs2   |   amoop   | width  |    vd    |0101111| VAMO*
  2      3     2        5          5         3          5        7

vs2[4:0] specifies v register holding address
vs3[4:0] specifies v register holding source operand
vd[4:0]  specifies v register destination of load

vm[1:0] specifies vector mask
width[2:0] specifies size of memory elements, and distinguishes from scalar AMO
amoop[4:0] specifies the AMO operation
----

[source]
----
Vector AMO width encoding
                     Width   Mem     Reg      Opcode
                     [2:0]   bits    bits

Standard scalar AMO   010     32     XLEN     AMO*.W
Standard scalar AMO   011     64     XLEN     AMO*.D
Standard scalar AMO   100    128     XLEN     AMO*.Q
Vector AMO            110     32    vl*SEW    VAMO*W.V
Vector AMO            111     64    vl*SEW    VAMO*D.V
Vector AMO            000    128    vl*SEW    VAMO*Q.V

Mem bits is the size of element accessed in memory
Reg bits is the size of element accessed in register
----

The vector AMO width encoding flips the high bit of the corresponding
scalar AMO width encoding.  SEW must be at least as wide as the AMO
memory element size, otherwise an illegal instruction exception is
raised.  If the AMO memory element width is less than SEW, the value
returned from memory is sign-extended to fill SEW.

If SEW is less than XLEN, then addresses in the vector `vs2` are
sign-extended to XLEN.  If SEW is greater than XLEN, an illegal
instruction exception is raised.

The vector `amoop[4:0]` field uses the same encoding as the scalar
5-bit AMO instruction field, except that LR and SC are not supported.

[source]
----
amoop   opcode
00001   vamoswap
00000   vamoadd
00100   vamoxor
01100   vamoand
01000   vamoor
10000   vamomin
10100   vamomax
11000   vamominu
11100   vamomaxu
----

== Vector Memory Consistency Model

Vector memory instructions appear to execute in program order on the
local hart.  Vector memory instructions follow RVWMO at the
instruction level, and element operations are ordered within the
instruction as if performed by an element-ordered sequence of
syntactically independent scalar instructions.  Vector indexed-ordered
stores write elements to memory in element order.  Vector
indexed-unordered stores do not preserve element order for writes
within a single vector store instruction.

NOTE: Need to flesh out details.

== Vector Arithmetic Instructions

The vector arithmetic instructions use a new major opcode (OP-V =
1010111~2~) which neighbors OP-FP, but generally follow the encoding
pattern of the scalar floating-point instructions under the OP-FP
opcode.

[source]
----
31        27 26 25 24      20 19       15 14    12 11         7 6     0
  funct5    |size |   rs2    |    rs1    |  rm    |      rd    |1010011| OP-FP scalar
    rs3     |size |   rs2    |    rs1    |  rm    |      rd    |100xx11| FMA scalar
     5         2        5          5         3            5        7

  funct5    | vm  |   vs2    |    vs1    | funct3 |     vd/rd  |1010111| OP-V.vv/.vs
  funct5    | vm  |   vs2    |    rs1    | funct3 |     vd/rd  |1010111| OP-V.vs/.vf
  funct5    | vm  |   vs2    |   simm5   | funct3 |     vd/rd  |1010111| OP-V.vi
    vs3     | vm  |   vs2    |    vs1    |  101   |      vd    |100xx11| VFMA.vv
    vs3     | vm  |   vs2    |    rs1    |  110   |      vd    |100xx11| VFMA.vs
     5         2        5          5         3            5        7
----


=== Vector Arithmetic Three-Address encoding

Operands for vector three-address binary arithmetic operations (two
sources and separate destination) are determined by the low two bits
of the `funct3` field.  The top bit of `funct3` is used in operation
encoding.

[source]
----
funct3[2:0]   Operands                 Source of scalar

x 0 0   Integer vector-vector          -
x 0 1   Integer vector-scalar    GPR x register rs1 or simm

x 1 0   FP vector-vector               -
x 1 1   FP vector-scalar         FP f register rs1
----

Integer operations are performed using unsigned or two's-complement
signed integer arithmetic depending on the opcode.

All standard vector floating-point arithmetic operations follow the
IEEE-754/2008 standard.  All vector floating-point operations use the
dynamic rounding mode in the `frm` register.

Vector-vector operations take two vectors of operands from vector
register groups specified by `vs2` and `vs1` respectively.

Vector-scalar operations can have three possible forms, but in all
cases take one vector of operands from a vector register group
specified by `vs2` and a second scalar source operand from one of
three alternative sources.

. For integer operations, the scalar can be a sign-extended 5-bit
immediate encoded in the `rs1` field.  The value is sign-extended to SEW bits.
. For integer operations, the scalar can be taken from the
scalar `x` register specified by `rs1`.  If XLEN>SEW, the
least-significant bits of the `x` register are used.  If XLEN<SEW, the
value from the `x` register is sign-extended to SEW bits.
. For floating-point operation, the scalar can be taken from
a scalar `f` register.  If FLEN>SEW, the least-significant bits of the
`f`register are used.  If FLEN<SEW, the value is NaN-boxed
(one-extended) to SEW.

NOTE: The proposed Zfinx variants will take the floating-point scalar
argument from the `x` registers.

Vector arithmetic instructions are masked under control of the `vm`
field.

[source]
----
Assembly syntax pattern for vector arithmetic instructions

# Operations returning vector results, masked by vm (v0.t, v0.f, <nothing>)
vop.vv  vd, vs2, vs1, vm  # integer vector-vector      vd[i] = vs2[i] op vs1[i]
vop.vs  vd, vs2, rs1, vm  # integer vector-scalar      vd[i] = vs2[i] op x[rs1]
vop.vi  vd, vs2, imm, vm  # integer vector-immediate   vd[i] = vs2[i] op imm

vfop.vv  vd, vs2, vs1, vm # FP vector-vector operation vd[i] = vs2[i] fop vs1[i]
vfop.vf  vd, vs2, rs1, vm # FP vector-scalar operation vd[i] = vs2[i] fop f[rs1]
----

NOTE: In the encoding, `vs2` is the first operand, while `rs1/simm5`
is the second operand. This is the opposite to the standard scalar
ordering.  This arrangment retains the property that instructions that
read only one scalar register, read it from `rs1`.  Also, that 5-bit
immediates are sourced from the `rs1` field.

=== Widening Vector Arithmetic Instructions

A few vector arithmetic instructions are defined to be __widening__
operations where the destination elements are 2*SEW wide and are
stored in a vector register group with twice the number of vector
registers, i.e., the destination vector register group is 2*LMUL.

The first operand can be either single or double-width. These are
generally written with a `vw*` prefix on the opcode.

NOTE: Originally, a `w` suffix was used on opcode, but this could be
confused with the use of a `w` suffix to mean word-sized operations in
doubleword integers, so the `w` was moved to prefix.

For integer multiply-add, another widening option increases the size
of the accumulator to 4*SEW (i.e., 4*SEW += SEW*SEW).  These are
distinguished by a `vw4*` prefix on the opcode.

For all widening instructions, the destination element width must be a
supported element width and the destination LMUL value must also be a
supported LMUL value (<=8), otherwise an illegal instruction exception
is raised.  The destination vector register group must be specified
using a vector register number that is valid for the destination's
LMUL value, otherwise an illegal instruction exception is raised.

[source]
----
Assembly syntax pattern for vector widening arithmetic instructions

# Double-width result, two single-width sources: 2*SEW = SEW op SEW
vwop.vv  vd, vs2, vs1, vm  # integer vector-vector      vd[i] = vs2[i] op vs1[i]
vwop.vs  vd, vs2, rs1, vm  # integer vector-scalar      vd[i] = vs2[i] op x[rs1]

# Double-width result, first source double-width, second source single-width: 2*SEW = 2*SEW op SEW
vwop.wv  vd, vs2, vs1, vm  # integer vector-vector      vd[i] = vs2[i] op vs1[i]
vwop.ws  vd, vs2, rs1, vm  # integer vector-scalar      vd[i] = vs2[i] op x[rs1]

# Quad-width result/third source, two single-width sources: 4*SEW = SEW op SEW
# Mainly used for 4*SEW += SEW * SEW integer widening multiply-adds
vw4op.vv  vd, vs2, vs1, vm
vw4op.vv  vd, vs2, vs1, vm
----

=== Narrowing Vector Arithmetic Instructions

A few instructions are provided to convert double-width source vectors
into single-width destination vectors.  These instructions convert
2*LMUL/2*SEW vectors/elements into LMUL/SEW vectors/elements.

If (2*LMUL > 8), or (2 * SEW) > ELEN, an illegal instruction exception
is raised.

The source and destination vector register groups have to be specified
with a vector register number that is legal for the source and
destination LMUL value respectively, otherwise an illegal instruction
exception is raised.

Where there is a second source vector, this has the same (narrower)
width as the result.

A `vn*` prefix on the opcode is used to distinguish these instructions
in the assembler.

NOTE: Comparison operations that set a mask register are also
implicitly a narrowing operation.

== Vector Integer Arithmetic Instructions

A set of vector integer arithmetic instructions are provided.  The
list of operations includes `vadd`, `vsub`, `vrsub`,`vwadd`, `vwsub`,
`vwadd.w, `vwwsub.w`, `vand`, `vor`, `vxor`, `vsll`, `vsrl`, `vsra`,
`vseq`, `vsne`, `vslt`, `vslte`, `vsltu`, `vslteu`, `vmin`, `vmax`,
`vminu`, `vmaxu`, `vmul`, `vmulh`, `vmulhu`, `vmulhsu`, `vwmul`,
vwmulu`, `vwmulsu`, `vdiv`, `vdivu`, `vrem`, `vremu`.

=== Vector Single-Width Integer Add and Subtract

Vector integer add and subtract are provided.  Reverse-subtract
instructions are also provided for the vector-scalar forms.

[source]
----
# Integer adds.
vadd.vv vd, vs2, vs1, vm   # Vector-vector
vadd.vs vd, vs2, rs1, vm   # vector-scalar
vadd.vi vd, vs2, imm, vm   # vector-immediate

# Integer subtract
vsub.vv vd, vs2, vs1, vm   # Vector-vector
vsub.vs vd, vs2, rs1, vm   # vector-scalar

# Integer reverse subtract
vrsub.vs vd, rs1, vs2, vm   # vd[i] = rs1 - vs2[i]
vrsub.vi vd, imm, vs2, vm   # vd[i] = imm - vs2[i]
----

=== Vector Widening Integer Add/Subtract

The widening add/subtract instructions are provided in both signed and
unsigned variants, depending on whether the narrower source operands
are first sign- or zero-extended before forming the double-width sum.

[source]
----
# Widening signed integer add/subtract, 2*SEW = SEW +/- SEW
vwadd.vv  vd, vs2, vs1, vm  # vector-vector
vwadd.vs  vd, vs2, rs1, vm  # vector-scalar
vwsub.vv  vd, vs2, vs1, vm  # vector-vector
vwsub.vs  vd, vs2, rs1, vm  # vector-scalar

# Widening signed integer add/subtract, 2*SEW = 2*SEW +/- SEW
vwadd.wv  vd, vs2, vs1, vm  # vector-vector
vwadd.ws  vd, vs2, rs1, vm  # vector-scalar
vwsub.wv  vd, vs2, vs1, vm  # vector-vector
vwsub.ws  vd, vs2, rs1, vm  # vector-scalar

# Widening unsigned integer add/subtract, 2*SEW = SEW +/- SEW
vwaddu.vv  vd, vs2, vs1, vm  # vector-vector
vwaddu.vs  vd, vs2, rs1, vm  # vector-scalar
vwsubu.vv  vd, vs2, vs1, vm  # vector-vector
vwsubu.vs  vd, vs2, rs1, vm  # vector-scalar

# Widening unsigned integer add/subtract, 2*SEW = 2*SEW +/- SEW
vwaddu.wv  vd, vs2, vs1, vm  # vector-vector
vwaddu.ws  vd, vs2, rs1, vm  # vector-scalar
vwsubu.wv  vd, vs2, vs1, vm  # vector-vector
vwsubu.ws  vd, vs2, rs1, vm  # vector-scalar
----

=== Vector Integer Add-with-Carry Instruction

To support multi-word arithmetic:
[source]
----
 # vd[i] = sum(vs1[i] + vs2[i] + v0[i].LSB)
 # v0[i] = carry(vs1[i] + vs2[i] + v0[i].LSB)

 vadc.vv   vd, vs2, vs1, v0
 vadc.vs   vd, vs2, rs1, v0
----

This instruction is unmasked, but uses the implicit mask register `v0`
as a carry input and carry output to the instruction.

The mask element in `v0` is written with the carry result in the LSB
and the upper bits of the mask element are set to 0.

=== Vector Bitwise Logical Instructions

[source]
----
# Bitwise logical operations.
vand.vv vd, vs2, vs1, vm   # Vector-vector
vand.vs vd, vs2, rs1, vm   # vector-scalar
vand.vi vd, vs2, imm, vm   # vector-immediate

vor.vv vd, vs2, vs1, vm    # Vector-vector
vor.vs vd, vs2, rs1, vm    # vector-scalar
vor.vi vd, vs2, imm, vm    # vector-immediate

vxor.vv vd, vs2, vs1, vm    # Vector-vector
vxor.vs vd, vs2, rs1, vm    # vector-scalar
vxor.vi vd, vs2, imm, vm    # vector-immediate
----

NOTE: With an immediate of -1, scalar-immediate forms of the `vxor`
instruction provide a bitwise NOT operation.  This can be provided as
an assembler pseudo-instruction `vnot.v`.

=== Vector Single-Width Bit Shift Instructions

A full complement of vector shift instructions are provided, including
logical shift left, and logical (zero-extending) and arithmetic
(sign-extending) shift right.

[source]
----
# Bit shift operations
vsll.vv vd, vs2, vs1, vm   # Vector-vector
vsll.vs vd, vs2, rs1, vm   # vector-scalar
vsll.vi vd, vs2, imm, vm   # vector-immediate

vsrl.vv vd, vs2, vs1, vm   # Vector-vector
vsrl.vs vd, vs2, rs1, vm   # vector-scalar
vsrl.vi vd, vs2, imm, vm   # vector-immediate

vsra.vv vd, vs2, vs1, vm   # Vector-vector
vsra.vs vd, vs2, rs1, vm   # vector-scalar
vsra.vi vd, vs2, imm, vm   # vector-immediate
----

Only the low lg2(SEW) bits are significant in specifying the shift
amount.

The immediate is treated as an unsigned shift amount, with a maxium
shift amount of 31.

=== Vector Narrowing Integer Shift Instructions

A few instructions are provided to convert double-width integer
elements into single-width elements using a combination of shifting,
rounding, and saturation.

The narrowing right shifts have both zero-extending (`srl`) and
sign-extending (`sra`) forms.  The shift amount can come from a vector
or a scalar `x` register or a 5-bit immediate.  The low lg2(2*SEW)
bits of the vector or scalar shift amount value are used (e.g., the
low 6 bits for a SEW=64-bit to SEW=32-bit narrowing operation).  The
immediate only supports shift amounts up to 31.

[source]
----
 # Narrowing shift right logical, SEW = (2*SEW) >> SEW
 vnsrl.vv vd, vs2, vs1, vm   # vector-vector
 vnsrl.vs vd, vs2, rs1, vm   # vector-scalar
 vnsrl.vi vd, vs2, imm, vm   # vector-immediate

 # Narrowing shift right arithmetic, SEW = (2*SEW) >> SEW
 vnsra.vv vd, vs2, vs1, vm   # vector-vector   
 vnsra.vs vd, vs2, rs1, vm   # vector-scalar   
 vnsra.vi vd, vs2, imm, vm   # vector-immediate
----

NOTE: The narrowing shifts can also be used to extract fields from a
structure held in a wider element.

NOTE: It could be useful to add support for `n4` variants, where the
destination is 1/4 width of source.

=== Vector Narrowing Fixed-Point Clip Instructions

The `vnclip` instructions are used to pack a fixed-point value into a
narrower destination.  The instructions support rounding, scaling, and
saturation into the final destination format.

[source]
----
 # Narrowing signed clip,  vd[i] = clip(round(vs1[i] + rnd) >> vs2[i])
 #                          SEW           2*SEW                 SEW 
 vnclip.vv vd, vs2, vs1, vm   # vector-vector
 vnclip.vs vd, vs2, rs1, vm   # vector-scalar
 vnclip.vi vd, vs2, imm, vm   # vector-immediate

 # Narrowing unsigned clip
 vnclipu.vv vd, vs2, vs1, vm   # vector-vector
 vnclipu.vs vd, vs2, rs1, vm   # vector-scalar
 vnclipu.vi vd, vs2, imm, vm   # vector-immediate
----

For `vnclip`/`vnclipu`, the rounding mode is specified in the `vxrm`
CSR.  Rounding occurs around the least-significant bit of the
destination and before saturation.

For `vnclip`, the shifted rounded source value is treated as a signed
integer and saturates if the result would overflow the destination viewed
as a signed integer.

For `vnclipu`, the shifted rounded source value is treated as an
unsigned integer and saturates if the result would overflow the
destination viewed as an unsigned integer.

If any destination element is saturated, the `vxsat` bit is set in the
`vxsat` register.

=== Vector Integer Comparison Instructions

The following integer compare instructions write `1` to the
destination mask register element if the comparison evaluates to true,
and `0` otherwise.  The destination mask vector is always held in a
single vector register, with a layout of elements as described in
Section <<sec-mask-register-layout>>.

[source]
----
# Set if equal
vseq.vv vd, vs2, vs1, vm   # Vector-vector
vseq.vs vd, vs2, rs1, vm   # vector-scalar
vseq.vi vd, vs2, imm, vm   # vector-immediate

# Set if not equal
vsne.vv vd, vs2, vs1, vm   # Vector-vector
vsne.vs vd, vs2, rs1, vm   # vector-scalar
vsne.vi vd, vs2, imm, vm   # vector-immediate

# Set if less than, signed
vslt.vv vd, vs2, vs1, vm   # Vector-vector
vslt.vs vd, vs2, rs1, vm   # vector-scalar
vslt.vi vd, vs2, imm, vm   # vector-immediate

# Set if less than, unsigned
vsltu.vv vd, vs2, vs1, vm   # Vector-vector
vsltu.vs vd, vs2, rs1, vm   # vector-scalar
vsltu.vi vd, vs2, imm, vm   # vector-immediate

# Set if less than or equal, signed
vsle.vv vd, vs2, vs1, vm   # Vector-vector
vsle.vs vd, vs2, rs1, vm   # vector-scalar

# Set if less than or equal, unsigned
vsleu.vv vd, vs2, vs1, vm   # Vector-vector
vsleu.vs vd, vs2, rs1, vm   # vector-scalar
----

NOTE: `VSNE` is not needed with complementing masks but sometimes
predicate results feed into things other than predicate inputs and so
`VSNE` can save an instruction.

NOTE: The immediate forms of sle{u} are not provided as the immediate
value can be increased by 1 and the slt{u} variants used instead.

These comparisons can effectively AND in the mask, e.g,

[source,asm]
----
    # (a < b) && (b < c) in two instructions
    vslt.vv    v0, va, vb        # All elements written
    vslt.vv    v0, vb, vc, v0.t  # Only update unmasked elements
----

Vector-vector instructions can switch source operand order to produce
all possible comparisons.  To obtain all comparisons with scalars,
the mask polarity can be complemented at use:

[source]
----
Provided:
vseq    v = s
vsne    v != s
vslt    v < s
vslte   v <= s

Equivalent:
vsgt    v > s   => !(v <= s) = !vslte
vsgte   v >= s  => !(v <  s) = !vslt
----

NOTE: If the boolean result is needed instead of the mask, then a
`vrsub.vi v0, 1, v0` instruction will perform a (1-x) boolean
inversion.

=== Vector Integer Min/Max Instructions

Signed and unsigned integer mininum and maximum instructions are
supported.

[source]
----
# Signed minimum
vmin.vv vd, vs2, vs1, vm   # Vector-vector
vmin.vs vd, vs2, rs1, vm   # vector-scalar

# Signed maximum
vmax.vv vd, vs2, vs1, vm   # Vector-vector
vmax.vs vd, vs2, rs1, vm   # vector-scalar

# Unsigned minimum
vminu.vv vd, vs2, vs1, vm   # Vector-vector
vminu.vs vd, vs2, rs1, vm   # vector-scalar

# Unsigned maximum
vmaxu.vv vd, vs2, vs1, vm   # Vector-vector
vmaxu.vs vd, vs2, rs1, vm   # vector-scalar
----

=== Vector Single-Width Integer Multiply Instructions

The single-width multiply instructions perform a SEW-bit*SEW-bit
multiply and return an SEW-bit-wide result.  The `*mulh*` versions
write the high word of the product to the destination register.

[source]
----
# Signed multiply, returning low bits of product
vmul.vv vd, vs2, vs1, vm   # Vector-vector
vmul.vs vd, vs2, rs1, vm   # vector-scalar

# Signed multiply, returning high bits of product
vmulh.vv vd, vs2, vs1, vm   # Vector-vector
vmulh.vs vd, vs2, rs1, vm   # vector-scalar

# Unsigned multiply, returning high bits of product
vmulhu.vv vd, vs2, vs1, vm   # Vector-vector
vmulhu.vs vd, vs2, rs1, vm   # vector-scalar

# Signed(vs2)-Unsigned multiply, returning high bits of product
vmulhsu.vv vd, vs2, vs1, vm   # Vector-vector
vmulhsu.vs vd, vs2, rs1, vm   # vector-scalar
----

NOTE: There is no `vmulhus` opcode to return high half of
unsigned-vector * signed-scalar product.

NOTE: The `vmulh*` opcodes perform simple fractional multiplies, but
with no option to round and/or saturate the result.

=== Vector Widening Integer Multiply Instructions

The widening integer multiply instructions return a 2*SEW-bit product
from an SEW-bit*SEW-bit multiply.

[source]
----
# Widening signed-integer multiply
vwmul.vv  vd, vs2, vs1, vm# vector-vector
vwmul.vs  vd, vs2, rs1, vm # vector-scalar

# Widening unsigned-integer multiply
vwmulu.vv vd, vs2, vs1, vm # vector-vector
vwmulu.vs vd, vs2, rs1, vm # vector-scalar

# Widening signed-unsigned integer multiply
vwmulsu.vv vd, vs2, vs1, vm # vector-vector
vwmulsu.vs vd, vs2, rs1, vm # vector-scalar
----

=== Vector Single-Width Integer Multiply-Add Instructions

The integer multiply-add instructions are destructive and are provided
in two forms, one that overwrites the addend (`vmacc`) and one that
overwrites the first multiplicand (`vmadd`).

[source]
----
# Signed-integer multiply-add, overwrite addend
vmacc.vv vd, vs2, vs1, vm    # vd[i] = vd[i] + (vs2[i] * vs1[i])
vmacc.vs vd, vs2, rs1, vm    # vd[i] = vd[i] + (vs2[i] * x[rs1])

# Signed-integer multiply-add, overwrite multiplicand
vmadd.vv vd, vs2, vs1, vm    # vd[i] = vs2[i] + (vd[i] * vs1[i])
vmadd.vs vd, vs2, rs1, vm    # vd[i] = vs2[i] + (vd[i] * x[rs1])

# Unsigned-integer multiply-add, overwrite addend
vmuluacc.vv vd, vs2, vs1, vm    # vd[i] = vd[i] + (vs2[i] * vs1[i])
vmuluacc.vs vd, vs2, rs1, vm    # vd[i] = vd[i] + (vs2[i] * x[rs1])

# Unsigned-integer multiply-add, overwrite multiplicand
vmuluadd.vv vd, vs2, vs1, vm    # vd[i] = vs2[i] + (vd[i] * vs1[i])
vmuluadd.vs vd, vs2, rs1, vm    # vd[i] = vs2[i] + (vd[i] * x[rs1])
----

=== Vector Widening Integer Multiply-Add Instructions

The widening integer multiply-add instructions add a SEW-bit*SEW-bit
multiply result to a 2*SEW-bit value and produce a 2*SEW-bit add
result.

[source]
----
# Signed-integer multiply-add, overwrite addend
vmacc.vv vd, vs2, vs1, vm    # vd[i] = vd[i] + (vs2[i] * vs1[i])
vmacc.vs vd, vs2, rs1, vm    # vd[i] = vd[i] + (vs2[i] * x[rs1])

# Signed-integer multiply-add, overwrite multiplicand
vmadd.vv vd, vs2, vs1, vm    # vd[i] = vs2[i] + (vd[i] * vs1[i])
vmadd.vs vd, vs2, rs1, vm    # vd[i] = vs2[i] + (vd[i] * x[rs1])
----

==== Vector Integer Divide Instructions

The divide and remainder instructions are equivalent to the RISC-V
standard scalar integer multiply/divides, with the same results for
extreme inputs.

[source,asm]
----
    # Signed divide
    vdiv.vv vd, vs2, vs1, vm   # Vector-vector
    vdiv.vs vd, vs2, rs1, vm   # vector-scalar

    # Unsigned divide.
    vdivu.vv vd, vs2, vs1, vm   # Vector-vector
    vdivu.vs vd, vs2, rs1, vm   # vector-scalar

    # Signed remainder
    vrem.vv vd, vs2, vs1, vm   # Vector-vector
    vrem.vs vd, vs2, rs1, vm   # vector-scalar

    # Unsigned remainder
    vremu.vv vd, vs2, vs1, vm   # Vector-vector
    vremu.vs vd, vs2, rs1, vm   # vector-scalar
----

NOTE: The decision to include integer divide and remainder was
contentious. The argument in favor is that without a standard
instruction, software would have to pick some algorithm to perform the
operation, which would likely perform poorly on some
microarchitectures versus others.

NOTE: There is no instruction to perform a "scalar divide by vector"
operation.

=== Vector Merge Instruction

The vector merge instruction combines two source operands based on the
mask field.  Where the mask value is zero, the first operand is copied
to the destination element, otherwise the second operand is copied to
the destination element.  The first operand is always a vector
register group.  The second operand is a vector or scalar value.

The set of active elements is all elements up to the current vector
length in `vl` regardless of mask value.

[source]
----
vmerge.vv vd, vs2, vs1, vm  # vd[i] = vm[i] ? vs1[i] : vs2[i]
vmerge.vs vd, vs2, rs1, vm  # vd[i] = vm[i] ? x[rs1] : vs2[i]
vmerge.vi vd, vs2, imm, vm  # vd[i] = vm[i] ? imm    : vs2[i]
----

NOTE: An unmasked `vmerge.vv` instruction can be used to copy one
vector register group to another.  This is given a vector
psuedo-instruction `vmv.vv vd, vs` (which expands to `vmerge.vv vd,
vs, vs`).  Microarchitectures can recognize this instruction to
avoid unnecessary vector register file accesses.

NOTE: An unmasked `vmerge.vs` or `vmerge.vs` instruction can be used
to __splat__ a scalar value into all elements of a vector.

NOTE: An unmasked `vmerge.vi` instruction can be used to initialize a
vector register group with an immediate value.  This is given a vector
pseudo-instruction `vmv.vi vd, imm`.

== Vector Floating-Point Instructions

The standard vector floating-point instructions treat 16-bit, 32-bit,
64-bit, and 128-bit elements as IEEE-754/2008-compatible values.  If
the current SEW does not correspond to a supported IEEE floating-point
type, an illegal instruction exception is raised.

NOTE: The floating-point element widths that are supported depend on
the platform.

NOTE: Platforms supporting 16-bit half-precision floating-point values
will also have to implement scalar half-precision floating-point
support in the `f` registers.

The vector floating-point instructions have the same behavior as the
scalar floating-point instructions with regard to NaNs.

Scalar values for vector-scalar operations can be sourced from the
standard scalar `f` registers.

NOTE: Scalar floating-point values will be sourced from the integer
`x` registers in the proposed Zfinx variant.

=== Vector Floating-Point Exception Flags

A vector floating-point exception at any active floating-point element
sets the standard FP exception flags in the `fflags` register.  Masked
elements do not set FP exception flags.

=== Vector Single-Width Floating-Point Add/Subtract Instructions

[source]
----
    # Floating-point add
    vfadd.vv vd, vs2, vs1, vm   # Vector-vector
    vfadd.vs vd, vs2, rs1, vm   # vector-scalar

    # Floating-point subtract
    vfsub.vv vd, vs2, vs1, vm   # Vector-vector
    vfsub.vs vd, vs2, rs1, vm   # vector-scalar
----

=== Vector Widening Floating-Point Add/Subtract Instructions

[source]
----
# Widening FP add/subtract, 2*SEW = SEW +/- SEW
vwfadd.vv vd, vs2, vs1, vm  # vector-vector
vwfadd.vs vd, vs2, rs1, vm  # vector-scalar
vwfsub.vv vd, vs2, vs1, vm  # vector-vector
vwfsub.vs vd, vs2, rs1, vm  # vector-scalar

# Widening FP add/subtract, 2*SEW = 2*SEW +/- SEW
vwfadd.wv  vd, vs2, vs1, vm  # vector-vector
vwfadd.ws  vd, vs2, rs1, vm  # vector-scalar
vwfsub.wv  vd, vs2, vs1, vm  # vector-vector
vwfsub.ws  vd, vs2, rs1, vm  # vector-scalar
----

=== Vector Single-Width Floating-Point Multiply/Divide Instructions

[source]
----
    # Floating-point multiply
    vfmul.vv vd, vs2, vs1, vm   # Vector-vector
    vfmul.vs vd, vs2, rs1, vm   # vector-scalar

    # Floating-point divide
    vfdiv.vv vd, vs2, vs1, vm   # Vector-vector
    vfdiv.vs vd, vs2, rs1, vm   # vector-scalar
----

=== Vector Widening Floating-Point Multiply

[source]
----
# Widening floating-point multiply
vwfmul.vv    vd, vs2, vs1, vm # vector-vector
vwfmul.vs    vd, vs2, rs1, vm # vector-scalar
----

=== Vector Single-Width Floating-Point Fused Multiply-Add Instructions

All four varieties of fused multiply-add are provided, and in two
destructive forms that overwrite one of the operands, either the
addend or the first multiplicand.

[source]
----
# FP multiply-add, overwrites multiplicand
vfmadd.vv vd, vs1, vs2, vm    # vd[i] = +(vd[i] * vs1[i]) + vs2[i]
vfmadd.vs vd, rs1, vs2, vm    # vd[i] = +(vd[i] * x[rs1]) + vs2[i]

# FP negate-(multiply-add), overwrites multiplicand
vfnmadd.vv vd, vs1, vs2, vm   # vd[i] = -(vd[i] * vs1[i]) - vs2[i]
vfnmadd.vs vd, rs1, vs2, vm   # vd[i] = -(vd[i] * x[rs1]) - vs2[i]

# FP multiply-sub, overwrites multiplicand
vfmsub.vv vd, vs1, vs2, vm    # vd[i] = +(vd[i] * vs1[i]) - vs2[i]
vfmsub.vs vd, rs1, vs2, vm    # vd[i] = +(vd[i] * x[rs1]) - vs2[i]

# FP negate-(multiply-sub), overwrites multiplicand
vfnmsub.vv vd, vs1, vs2, vm   # vd[i] = -(vd[i] * vs1[i]) + vs2[i] 
vfnmsub.vs vd, rs1, vs2, vm   # vd[i] = -(vd[i] * x[rs1]) + vs2[i] 

# FP multiply-accumulate, overwrites addend
vfmacc.vv vd, vs1, vs2, vm    # vd[i] = +(vs2[i] * vs1[i]) + vd[i]
vfmacc.vs vd, rs1, vs2, vm    # vd[i] = +(vs2[i] * x[rs1]) + vd[i]

# FP negate-(multiply-accumulate), overwrites addend
vfnmacc.vv vd, vs1, vs2, vm   # vd[i] = -(vs2[i] * vs1[i]) - vd[i]
vfnmacc.vs vd, rs1, vs2, vm   # vd[i] = -(vs2[i] * x[rs1]) - vd[i]

# FP multiply-subtract-accumulator, overwrites addend
vfmsac.vv vd, vs1, vs2, vm    # vd[i] = +(vs2[i] * vs1[i]) - vd[i]
vfmsac.vs vd, rs1, vs2, vm    # vd[i] = +(vs2[i] * x[rs1]) - vd[i]

# FP negate-(multiply-subtract-accumulator), overwrites addend
vfnmsac.vv vd, vs1, vs2, vm   # vd[i] = -(vs2[i] * vs1[i]) + vd[i]
vfnmsac.vs vd, rs1, vs2, vm   # vd[i] = -(vs2[i] * x[rs1]) + vd[i]
----

NOTE: It would be possible to use the two unused rounding modes in the
scalar FP FMA encoding to provide a few non-destructive FMAs. However,
this would be only maskable operation with three inputs and separate
output.

=== Vector Widening Floating-Point Fused Multiply-Add Instructions

The widening floating-point fused multiply-add instructions all
overwrite the wide addend with the result.  The multiplier inputs are
all SEW wide, while the addend and destination is 2*SEW bits wide.

[source]
----
# FP widening multiply-accumulate, overwrites addend
vwfmacc.vv vd, vs1, vs2, vm    # vd[i] = +(vs2[i] * vs1[i]) + vd[i]
vwfmacc.vs vd, rs1, vs2, vm    # vd[i] = +(vs2[i] * x[rs1]) + vd[i]

# FP widening negate-(multiply-accumulate), overwrites addend
vwfnmacc.vv vd, vs1, vs2, vm   # vd[i] = -(vs2[i] * vs1[i]) - vd[i]
vwfnmacc.vs vd, rs1, vs2, vm   # vd[i] = -(vs2[i] * x[rs1]) - vd[i]

# FP widening multiply-subtract-accumulator, overwrites addend
vwfmsac.vv vd, vs1, vs2, vm    # vd[i] = +(vs2[i] * vs1[i]) - vd[i]
vwfmsac.vs vd, rs1, vs2, vm    # vd[i] = +(vs2[i] * x[rs1]) - vd[i]

# FP widening negate-(multiply-subtract-accumulator), overwrites addend
vwfnmsac.vv vd, vs1, vs2, vm   # vd[i] = -(vs2[i] * vs1[i]) + vd[i]
vwfnmsac.vs vd, rs1, vs2, vm   # vd[i] = -(vs2[i] * x[rs1]) + vd[i]
----

=== Vector Floating-Point Square-Root Instruction

This is a unary vector-vector instruction.

[source]
----
    # Floating-point square root
    vfsqrt.v vd, vs2, vm   # Vector-vector square root
----

=== Vector Floating-Point MIN/MAX Instructions

The vector floating-point `vfmin` and `vfmax` instructions have the
same behavior as the corresponding scalar floating-point instructions
in version 2.2 of the RISC-V F extension.

[source]
----
    # Signed minimum
    vfmin.vv vd, vs2, vs1, vm   # Vector-vector
    vfmin.vs vd, vs2, rs1, vm   # vector-scalar

    # Signed maximum
    vfmax.vv vd, vs2, vs1, vm   # Vector-vector
    vfmax.vs vd, vs2, rs1, vm   # vector-scalar
----

=== Vector Floating-Point Sign-Injection Instructions

Vector versions of the scalar sign-injection instructions.  The result
takes all bits except the sign bit from the vector `vs2` operands.

[source]
----
    vfsgnj.vv vd, vs2, vs1, vm   # Vector-vector
    vfsgnj.vs vd, vs2, rs1, vm   # vector-scalar

    vfsgnjn.vv vd, vs2, vs1, vm   # Vector-vector
    vfsgnjn.vs vd, vs2, rs1, vm   # vector-scalar

    vfsgnjx.vv vd, vs2, vs1, vm   # Vector-vector
    vfsgnjx.vs vd, vs2, rs1, vm   # vector-scalar
----

=== Vector Floating-Point Compare Instructions

These vector FP compare instructions compare two source operands and
write the comparison result to a mask register.  The destination mask
vector is always held in a single vector register, with a layout of
elements as described in Section <<sec-mask-register-layout>>.

The compare instructions follow the semantics of the scalar
floating-point compare instructions.

[source]
----
    # Compare equal
    vfeq.vv vd, vs2, vs1, vm   # Vector-vector
    vfeq.vs vd, vs2, rs1, vm   # vector-scalar

    # Compare less than
    vflt.vv vd, vs2, vs1, vm   # Vector-vector
    vflt.vs vd, vs2, rs1, vm   # vector-scalar

    # Compare less than or equal
    vflte.vv vd, vs2, vs1, vm   # Vector-vector
    vflte.vs vd, vs2, rs1, vm   # vector-scalar 
----

NOTE: Need to revisit support for unordered comparisons.

=== Vector Floating-Point Classify Instruction

This is a unary vector-vector instruction that operates in the same
way as the scalar classify instruction.

[source]
----
    vfclass.v vd, vs2, vs1, vm   # Vector-vector
----

The 10-bit mask produced by this instruction is placed in the
least-significant bits of the result elements.  The instruction is
only defined for SEW=16b and above, so the result will always fit in
the destination elements.

=== Single-Width Floating-Point/Integer Type-Convert Instructions

Conversion operations are provided to convert to and from
floating-point values and signed and unsigned integers, where both
source and destination are SEW wide.

[source]
----
vfcvt.x.f.v  vd, vs2, vm   # Convert float to signed integer.
vfcvt.xu.f.v vd, vs2, vm   # Convert float to unsigned integer.

vfcvt.f.x.v  vd, vs2, vm   # Convert signed integer to float.
vfcvt.f.xu.v vd, vs2, vm   # Convert unsigned integer to float.
----

The conversions follow the same rules on exceptional conditions as the
scalar conversion instructions.  The conversions always used the
dynamic rounding mode in `frm`.

=== Widening Floating-Point/Integer Type-Convert Instructions

A set of conversion instructions are provided to convert between
narrower integer and floating-point datatypes to a type of twice the
width.

[source]
----
vwfcvt.x.f.v  vd, vs2, vm   # Convert float to double-width signed integer.
vwfcvt.xu.f.v vd, vs2, vm   # Convert float to double-width unsigned integer.

vwfcvt.f.x.v  vd, vs2, vm   # Convert signed integer to double-width float.
vwfcvt.f.xu.v vd, vs2, vm   # Convert unsigned integer to double-width float.

vwfcvt.f.f.v vd, vs2, vm   # Convert single-width float to double-width float.
----

NOTE: A double-width IEEE floating-point value can always represent a
single-width integer exactly.

NOTE: A double-width IEEE floating-point value can always represent a
single-width IEEE floating-point value exactly.

NOTE: A full set of floating-point widening conversions are not
supported as single instructions, but any widening conversion can be
implemented as several doubling steps with equivalent results and no
additional exception flags raised.

NOTE: An integer value can be doubled in width using the widening add
instructions with a scalar operand of `x0`.  Can define assembly
pseudo-ops `vwcvt.x.x.v vd,vs = vwadd.vs vd,vs,x0` and `vwcvtu.x.x.v
vd,vs = vwaddu.vs vd,vs,x0`.

=== Narrowing Floating-Point/Integer Type-Convert Instructions

A set of convertion instructions are provided to convert wider integer
and floating-point datatypes to a type of half the width.

[source]
----
vnfcvt.x.f.v  vd, vs2, vm   # Convert double-width float to signed integer.
vnfcvt.xu.f.v vd, vs2, vm   # Convert double-width float to unsigned integer.

vnfcvt.f.x.v  vd, vs2, vm   # Convert double-width signed integer to float.
vnfcvt.f.xu.v vd, vs2, vm   # Convert double-width unsigned integer to float.

vnfcvt.f.f.v vd, vs2, vm   # Convert double-width float to single-width float.
----

NOTE: A full set of floating-point widening conversions are not
supported as single instructions. Conversions can be implemented in
several halving steps, with equivalently rounded results and with the
same exception flags raised (possibly raised redundantly in multiple
steps).

NOTE: An integer value can be halved in width using the narrowing
integer shift instructions with a shift amount of 0.

== Vector Reduction Operations

Vector reduction operations takes a vector of elements and a scalar
held in the zeroth element of a vector, and performs a reduction using
some binary operator, to produce a scalar result in element 0 of a
vector register.  Masked inactive elements are excluded from the
reduction.

=== Vector Single-Width Integer Reduction Instructions

[source]
----
    vredsum.vv  vd, vs2, vs1, vm   # vd[0] = sum_i( vs2[i] ) + vs1[0]
    vredmax.vv  vd, vs2, vs1, vm   # vd[0] = max_i( vs2[i] ) + vs1[0]
    vredmaxu.vv vd, vs2, vs1, vm   # vd[0] = maxu_i( vs2[i] ) + vs1[0]
    vredmin.vv  vd, vs2, vs1, vm   # vd[0] = min_i( vs2[i] ) + vs1[0]
    vredminu.vv vd, vs2, vs1, vm   # vd[0] = minu_i( vs2[i] ) + vs1[0]
    vredand.vv  vd, vs2, vs1, vm   # vd[0] = and_i( vs2[i] ) + vs1[0]
    vredor.vv   vd, vs2, vs1, vm   # vd[0] = or_i( vs2[i] ) + vs1[0]
    vredxor.vv  vd, vs2, vs1, vm   # vd[0] = xor_i( vs2[i] ) + vs1[0]
----

=== Vector Widening Integer Reduction Instructions

The `vwredsum.vv` instruction uses double-width vector elements for
the input and output scalar values.

[source]
----
    vwredsum.vv  vd, vs2, vs1, vm   # 2*SEW = sum(SEW) + 2*SEW
----

=== Vector Single-Width Floating-Point Reduction Instructions

[source]
----
    vfredsum.v  vd, vs2, vs1, vm  # Ordered reduce
    vfredusum.v  vd, vs2, vs1, vm # Unordered reduce
    vfredmax.v  vd, vs2, vs1, vm  
    vfredmin.v  vd, vs2, vs1, vm
----

The `vfredsum` instruction performs the sum reduction in element
order, while the `vfredusum` is allowed to perform the reduction in
any order, but the result must correspond to some ordering of
individual sequential reduction operations.

NOTE: Can fmax and fmin be defined to not need an unordered variant?

=== Vector Widening Floating-Point Reduction Instructions

Widening forms of the sum reduction are provided that write a
double-width reduction result.

[source]
----
    vwfredsum.v  vd, vs2, vs1, vm  # Ordered reduce
    vwfredusum.v  vd, vs2, vs1, vm # Unordered reduce
----

== Vector Mask Instructions

Several instructions are provided to help operate on mask values held in
a vector register. 

=== Vector Mask-Register Logical Instructions

Vector mask-register logical operations treat mask registers as a
vector of VLEN bits and perform bitwise operations on all bits.  These
instructions all operate on single vector registers as if LMUL=1,
regardless of the setting of the `vlmul` field in `vtype`.  They do
not change the value of `vlmul`.

Vector mask-register logical operations are always unmasked, but
destination tail mask elements, i.e. those past the current length
setting in `vl`, are zeroed.

[source]
----
    vmand.vv vd, vs2, vs1     # vd =   vs2 &  vs1
    vmnand.vv vd, vs2, vs1    # vd = ~(vs2 &  vs1)
    vmandnot.vv vd, vs2, vs1  # vd =   vs2 & ~vs1
    vmxor.vv  vd, vs2, vs1    # vd =   vs2 ^  vs1
    vmor.vv  vd, vs2, vs1     # vd =   vs2 |  vs1
    vmnor.vv  vd, vs2, vs1    # vd = ~(vs2 |  vs1)
    vmornot.vv  vd, vs2, vs1  # vd =   vs2 | ~vs1
    vmxnor.vv  vd, vs2, vs1   # vd = ~(vs2 ^  vs1)
----

Several assembler psuedo-instructions are defined as shorthand for
common uses of mask logical operations:
[source]
----
    vmmv.v vd, vs  => vmand.vv vd, vs, vs  # Move mask register
    vmclr.v vd     => vmxor.vd, vd, vd     # Clear mask register
    vmset.v vd     => vmxnor.vd, vd, vd    # Set mask register
    vmnot.v vd, vs => vmnand.vv vd, vs, vs # Invert bits
----

The set of eight mask logical instructions can generate any of the 16
possibly binary logical functions of the two input masks:

[source]
----
inputs
0 0 1 1 src1
0 1 0 1 src2

output  instruction                 psuedo-instruction
0 0 0 0 vmxor.vv vd, vd, vd         vmclr.v vd
1 0 0 0 vmnor.vv vd, src1, src2
0 1 0 0 vmandnot.vv vd, src2, src1
1 1 0 0 vmnand.vv vd, src1, src1    vmnot.v vd, src1
0 0 1 0 vmandnot.vv vd, src1, src2
1 0 1 0 vmnand.vv vd, src2, src2    vmnot.v vd, src2
0 1 1 0 vmxor.vv vd, src1, src2
1 1 1 0 vmnand.vv vd, src1, src2
0 0 0 1 vmand.vv vd, src1, src2
1 0 0 1 vmxnor.vv vd, src1, src2
0 1 0 1 vmand.vv vd, src2, src2     vmmv.v vd, src2
1 1 0 1 vmornot.vv vd, src2, src1
0 0 1 1 vmand.vv vd, src1, src1     vmmv.v vd, src1
1 0 1 1 vmornot.vv vd, src1, src2
1 1 1 1 vmxnor.vv vd, vd, vd        vmset.v vd
----

NOTE: The vector mask logical instructions are designed to be easily fused
with a following masked vector operation to effectively expand the
number of predicate registers.


=== `vmpopc` mask population count

[source]
----
    vmpopc rd, vs1, vm
----

The `vmpopc` instruction counts the number of elements of the first
`vl` elements of the vector source that have their low bit set,
excluding elements where the mask is false, and writes the result to a
GPR.

=== `vmfirst` find-first-set mask bit

[source]
----
    vmfirst rd, vs1, vm
----

The `vmfirst` instruction finds the lowest-numbered element of the
source vector that has its LSB set excluding elements where the mask
is false, and writes that element's index to a GPR.  If no element has
an LSB set, it writes -1 to the GPR.

=== Vector Iota instruction

The VIOTA instruction reads `v0` and writes to each element of the
destination the sum of all the least-significant bits of elements in
the mask selected by m[1:0] with index less than the element, e.g., a
parallel prefix sum of the mask values.

If the value would overflow the destination, the least-significant
bits are retained.  This instruction is not masked, so writes all `vl`
elements of destination vector.

[source]
----
 viota.v vd        # Unmasked, writes index to each element, vd[i] = i
 viota.v vd, v0.t  # Writes to each element, sum of preceding true elements.

 # Example

     7 6 5 4 3 2 1 0   Element number
     1 0 0 1 0 0 0 1   v0 contents

     7 6 5 4 3 2 1 0   viota.v vd
     2 2 2 1 1 1 1 0   viota.v vd, v0.t
     5 4 3 3 2 1 0 0   viota.v vd, v0.f
----

NOTE: The `viota` instruction can be combined with scatter/gather
instructions to perform vector compress/expand instructions.

NOTE: Could take any argument register not just implicit mask v0.

=== `vmsbf.v` set-before-first mask bit

[source]
----
    vmsbf.v vd, vs1, vm

 # Example

     7 6 5 4 3 2 1 0   Element number

     1 0 0 1 0 1 0 0   v3 contents
                       vmsbf.v v2, v3
     0 0 0 0 0 0 1 1   v2 contents

     1 0 0 1 0 1 0 1   v3 contents
                       vmsbf.v v2, v3
     0 0 0 0 0 0 0 0   v2

     0 0 0 0 0 0 0 0   v3 contents
                       vmsbf.v v2, v3
     1 1 1 1 1 1 1 1   v2

     1 1 0 0 0 0 1 1   v0 vcontents
     1 0 0 1 0 1 0 0   v3 contents
                       vmsbf.v v2, v3, v0.t
     0 1 x x x x 1 1   v2 contents
----

The `vmsbf.v` instruction writes a 1 to all active elements before the
first source element that has a set LSB, then writes a zero to that
element and all following active elements.  If there is no set bit in
the source vector, the all active elements in the destination are
written with a 1.

=== `vmsif.v` set-including-first mask bit

[source]
----
    vmsif.v vd, vs1, vm

 # Example

     7 6 5 4 3 2 1 0   Element number

     1 0 0 1 0 1 0 0   v3 contents
                       vmsif.v v2, v3
     0 0 0 0 0 1 1 1   v2 contents

     1 0 0 1 0 1 0 1   v3 contents
                       vmsif.v v2, v3
     0 0 0 0 0 0 0 1   v2

     1 1 0 0 0 0 1 1   v0 vcontents
     1 0 0 1 0 1 0 0   v3 contents
                       vmsif.v v2, v3, v0.t
     1 1 x x x x 1 1   v2 contents
----

The vector mask set-including-first instruction is similar to
set-before-first, except it also includes the element with a set bit.

=== `vmsof.v` set-only-first mask bit

[source]
----
    vmsof.v vd, vs1, vm

 # Example

     7 6 5 4 3 2 1 0   Element number

     1 0 0 1 0 1 0 0   v3 contents
                       vmsof.v v2, v3
     0 0 0 0 0 1 0 0   v2 contents

     1 0 0 1 0 1 0 1   v3 contents
                       vmsof.v v2, v3
     0 0 0 0 0 0 0 1   v2

     1 1 0 0 0 0 1 1   v0 vcontents
     1 1 0 1 0 1 0 0   v3 contents
                       vmsof.v v2, v3, v0.t
     0 1 x x x x 0 0   v2 contents
----

The vector mask set-including-first instruction is similar to
set-before-first, except it only sets the first element with a bit
set, if any.

=== Example using vector mask instructions

The following is an example of vectorizing a data-dependent exit loop.

[source]
----
  # char* strcpy(char *dst, const char* src)
strcpy:
      mv a2, a0               # Copy dst
loop:
    setvli x0, x0, vint8    # Max length vectors of bytes
    vlbuff.v v1, (a1)        # Get src bytes
      csrr t1, vl           # Get number of bytes fetched
    vseq.vi v0, v1, 0       # Flag zero bytes
    vmfirst a3, v0          # Zero found?
      add a1, a1, t1        # Bump pointer
    vmsif.v v0, v0          # Set mask up to and including zero byte.
    vsb.v v1, (a2), v0.t    # Write out bytes
      add a2, a2, t1        # Bump pointer
      bltz a3, loop

      ret

  # char* strncpy(char *dst, const char* src, size_t n)
strncpy:
      mv a3, a0               # Copy dst
loop:
    setvli x0, a2, vint8    # Vectors of bytes.
    vlbuff.v v1, (a1)       # Get src bytes
    vseq.vi v0, v1, 0       # Flag zero bytes
    vmfirst a4, v0          # Zero found?
    vmsif.v v0, v0          # Set mask up to and including zero byte.
    vsb.v v1, (a3), v0.t    # Write out bytes
      bgez a4, exit         # Done
      csrr t1, vl           # Get number of bytes fetched
      add a1, a1, t1        # Bump pointer
      sub a2, a2, t1        # Decrement count.
      add a3, a3, t1        # Bump pointer
      bnez a2, loop         # Anymore?

exit:
      ret

----


== Vector Permutation Instructions

A range of permutation instructions are provided.

=== Insert/Extract

The first form of insert/extract operations transfer a single value
between a GPR and one element of a vector register.  A second scalar
GPR operand gives the element index, treated as an unsigned integer.
If the index is out of range on a vector extract, then zero is
returned for the element value.  If the index is out of range (i.e.,
stem:[>VLMAX]) for a vector insert, the write is ignored.

[source]
----
vmv.x.v rd, vs1, rs2  # rd = vs1[rs2]
vmv.v.x vd, rs1, rs2  # vd[rs2] = rs1
----

The second form of insert/extract transfers a single value between
element 0 of one vector register and one indexed element of a second
vector register.

[source]
----
vmv.s.v vd, vs1, rs2 # vd[0] = vs1[rs2]
vmv.v.s vd, vs1, rs2 # vd[rs2] = vs1[0]
----

=== Slides

The slide instructions move elements up and down a vector.

[source]
----
 vslideup.vs vd, vs1, rs2, vm   # vd[i+rs2] = vs1[i]
 vslideup.vi vd, vs1, imm, vm   # vd[i+imm] = vs1[i]
----

For `vslideup`, the value in `vl` specifies the number of source
elements that are read.  The destination elements below the start
index are left undisturbed.  Destination elements past `vl` can be
written, but writes past the end of the destination vector are
ignored.

[source]
----
 vslidedown.vs vd, vs1, rs2, vm # vd[i] = vs1[i+rs2]
 vslidedown.vi vd, vs1, imm, vm # vd[i] = vs1[i+imm]
----

For `vslidedown`, the value in `vl` specifies the number of
destination elements that are written.  Elements in the source vector
can be read past `vl`.  If a source vector index is out of range, zero
is returned for the element.

=== Register Gather

This instruction reads elements from a source vector at locations
given by a second source element index vector.  The values in the
index vector are treated as unsigned integers. The number of elements
to write to the destination register is given by `vl`.  The source
vector can be read at any index, stem:[index < VLMAX ].

[source]
----
vrgather.vv vd, vs1, vs2, vm # vd[i] = vs1[vs2[i]]
----

If the element indices are out of range ( stem:[ vs2[i\] \geq VLMAX] )
then zero is returned for the element value.

== Register Constraints on Mixed-Width Instructions

A given vector register cannot be read and written with different
element widths in the same vector instruction, including mask register
values.  The effective width of a mask register element is SEW/LMUL.

NOTE: This constraint is to simplify implementations that
incrementally update vector registers in place.  The constraint can
probably be loosened for certain combinations.

== Exception Handling

Different platforms require different treatment of exceptions.

=== `*progress` CSR

In all platforms, a new "progress" CSR is defined and is made visible
in any privilege mode that can observe a partially completed vector
instruction.

On a trap during a vector instruction, the existing `*epc` CSR is
written with a pointer to the errant vector instruction, while the
`*progress` CSR contains the element index that caused the trap to be
taken.

All vector instructions are defined to begin execution with the
element number given in the `*progress` CSR, leaving earlier elements
in the vector undisturbed, and to reset the `*progress` CSR to zero
for the start of the subsequent vector instruction.

If the value in the `*progress` register is >= `vl` then no elemental
operations are performed, and the `*progress` register is reset to
zero.

=== Precise vector traps

Precise vector traps, require that:

 - all instructions older than the trapping vector instruction have committed their results
 - no instructions newer than the trapping vector instruction have altered architectural state
 - any operations within the trapping vector instruction affecting result elements preceding the index in the `*progress` CSR have committed their results
 - no operations within the trapping vector instruction affecting elements at or following the `*progress` CSR have committed their results

NOTE: We assume most supervisor-mode environments will require precise
vector traps.

NOTE: We chose to add a progress CSR to allow resumption of a
partially executed vector instruction.  This matches the scheme in the
IBM 3090 vector facility.  Without the progress CSR, to ensure forward
progress implementations would have to guarantee an entire vector
instruction can always complete atomically without generating a trap.
This is particularly difficult to ensure in the presence of
strided or scatter/gather operations.

=== Imprecise vector traps

Imprecise vector traps are traps that are not precise.  In particular,
instructions newer than `*epc` may have committed results, and
instructions older than `*epc` may have not completed execution.
Imprecise traps are primarily intended to be used in situations where
reporting an error and terminating execution is the appropriate
response.

NOTE: A platform might specify that interrupts are precise while other
traps are imprecise.  We assume many embedded platforms will only
generate imprecise traps for vector instructions on fatal errors, so
do not require resumable traps.

=== Selectable precise/imprecise traps

Some platforms may choose to provide a mode bit in a CSR to select
between precise and imprecise vector traps.  Precise mode would run
more slowly, but support debugging of errors, while imprecise mode
would run at high-performance but possibly obscure error conditions.

NOTE: It is acknowledged that some errors will only manifest in
imprecise mode.

=== Swappable traps

Another trap mode can support swappable state in the vector unit,
where on a trap, special instructions can save and restore the vector
unit microarchitectural state, to allow execution to continue
correctly around imprecise traps.

This is not defined in base vector ISA.

== Vector Assembly Code Examples

The following are provided as non-normative text to help explain the vector ISA.

=== Vector-vector add example

[source]
----
    # vector-vector add routine of 32-bit integers
    # void vvaddint32(size_t n, const int*x, const int*y, int*z)
    # { for (size_t i=0; i<n; i++) { z[i]=x[i]+y[i]; } }
    #
    # a0 = n, a1 = x, a2 = y, a3 = z
    # Non-vector instructions are indented
vvaddint32:
    vsetvli t0, a0, vint32 # Set vector length based on 32-bit vectors
    vlw.v v0, (a1)           # Get first vector
      sub a0, a0, t0         # Decrement number done
      slli t0, t0, 2         # Multiply number done by 4 bytes
      add a1, a1, t0         # Bump pointer
    vlw.v v1, (a2)           # Get second vector
      add a2, a2, t0         # Bump pointer
    vadd.v v2, v0, v1        # Sum vectors
    vsw.v v2, (a3)           # Store result
      add a3, a3, t0         # Bump pointer
      bnez a0, vvaddint32    # Loop back
      ret                    # Finished
----

=== Memcpy example

[source]
----
    # void *memcpy(void* dest, const void* src, size_t n)
    # a0=dest, a1=src, a2=n
    #
  memcpy:
      mv a3, a0 # Copy destination
  loop:
    vsetvli t0, a2, vint8,vlmul8  # Vectors of 8b
    vlb.v v0, (a1)                # Load bytes
      add a1, a1, t0              # Bump pointer
      sub a2, a2, t0              # Decrement count
    vsb.v v0, (a3)                # Store bytes
      add a3, a3, t0              # Bump pointer
      bnez a2, loop               # Any more?
      ret                         # Return
----

=== Conditional example

[source]
----
       (int16) z[i] = ((int8) x[i] < 5) ? (int16) a[i] : (int16) b[i];

Fixed 16b SEW:
loop:
    vsetvli t0, a0, vint16  # Use 16b elements.
    vlb.v v0, (a1)               # Get x[i], sign-extended to 16b
      sub a0, a0, t0           # Decrement element count
      add a1, a1, t0           # x[i] Bump pointer
    vslti v0, v0, 5            # Set mask in v0
      slli t0, t0, 1             # Multiply by 2 bytes
    vlh.v v1, (a2), v0.t         # z[i] = a[i] case
      add a2, a2, t0           # a[i] bump pointer
    vlh.v v1, (a3), v0.f         # z[i] = b[i] case
      add a3, a3, t0           # b[i] bump pointer
    vsh.v v1, (a4)               # Store z
      add a4, a4, t0           # b[i] bump pointer
      bnez a0, loop
----

=== VLmul example

Out of date.

[source]
----
    # Example using vlmul
    # Same as before, except now VLEN is 8 times greater.
strlen:
    mv a3, a0             # Save start
loop:
    setvli a1, x0, vint8, vreg4  # Vector of bytes, only use 4 vregs
    vlbuff.v v1, (a3)     # Get bytes
    csrr a1, vl           # Get bytes read
    add a3, a3, a1        # Bump pointer
    vseq.vi v0, v1, 0     # Set v0[i] where v1[i] = 0
    vmfirst a2, v0        # Find first set bit
    bltz a2, loop         # Not found?

    add a0, a0, a1        # Sum start + bump
    add a3, a3, a2        # Add index
    sub a0, a3, a0        # Subtract start address+bump

    ret

----



== Expanded SEW encoding

As an extension, the vsew field is extended with three upper bits.

[source]
----
  vsew[2:0] (standard element width) encoding

  vsew[2:0]   SEW
  ---        ----
  000           8
  001          16
  010          32
  011          64
  100         128
  101         256
  110         512
  111        1024

  vxsew[5:0] (expanded element width) encoding

  vxsew[5:0]  SEW
  ---        ----
  000000       8
  001000       1
    ...          1..8, steps of 1
  111000       7
  000001      16
  001001       9
    ...          9..16, steps of 1
  111001      15
  000010      32
  001010      18
    ...          18-32, steps of 2
  111010      30

  ...TBD

----

== Vector Instruction Listing

include::inst-table.adoc[]
