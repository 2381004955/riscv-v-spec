= Vector extension
Proposal for "low-config" redesign 
:doctype: article
:encoding: utf-8
:lang: en
:toc: left
:numbered:
:stem: latexmath

== Note

These are working notes only.

== Implementation-defined constant parameters

These parameters are fixed for a given machine.  The ISA supports
writing code that is portable across machines with different values
for these parameters, under certain constraints.

The maximum size of a single vector element in bits, stem:[ELEN \geq
max(XLEN,FLEN) ]. Must be a power of 2.

The number of bits in a vector register, stem:[VLEN \geq ELEN].  Must
be a power of 2.

NOTE: Platform profiles may set further constraints on these
parameters, for example, requiring a minimm stem:[VLEN] or stem:[ELEN] value.

NOTE: Vector contexts cannot be migrated across vector units with
different VLEN and ELEN settings.

== Vector Register File

There are 32 architectural vector registers, `v0`-`v31`.

Each vector register has a fixed stem:[VLEN] bits of state.

If the system has floating-point registers, the floating-point
register ``f``__x__ is contained in the low stem:[FLEN] bits of vector
register ``v``__x__.

[source]
----
Example, FLEN=32, VLEN=64

bytes        7 6 5 4 3 2 1 0
            |       v0      |
                    |  f0   |
----

NOTE: Because bits within an element are numbered in a little-endian
format with increasing bit index corresponding to increasing
magnitude, and because RISC-V is little-endian, vector register
layouts are drawn with bytes ordered from right to left with
increasing byte address.
 
NOTE: Zfinx ("F in X") is a new ISA option under consideration where
floating-point instructions take their arguments from the integer
register file.  The vector extension is incompatible with this option.
Overlaying vectors on the integer registers for Zfinx would need
different code to avoid integer registers with special meanings in the
ABI, e.g., `x0` and `x1`.

==  Vector CSRs

Three new XLEN-width unprivileged CSRs are added: `vtype`, `vl`,
`vlmax`.

== Vector type register, `vtype`

The XLEN-wide _vector_ _type_ CSR, `vtype` provides the default type
of variables contained in the vector register file, and used to
provide a polymorphic interpretation for vector instructions. The
vector type also determines the number of elements that are held in
each vector register.

The `type` register has two fields, `vrep`, and `vsew`.

[source]
----
vtype layout

XLEN-1:5    Reserved (write 0)
     3:1    vsew[2:0]
      0     vrep
----

Not all combinations of values in the three fields will be supported
on an implementation.

NOTE: Further standard and custom extensions to the vector base will
extend these three fields to support a greater variety of data types.

=== Vector representation `vrep` encoding

The `vrep` field specifies how the bit patterns stored in each element
are to be interpeted.  Integer instructions can also explicitly treat
their operands as signed or unsigned.

[source]
----
 'vrep' representation field encoding

 0  Signed two's-complement integer  
 1  IEEE-754/2008 floating-point
----

=== Vector standard element width `vsew`

The value in `vsew` sets the dynamic _standard_ _element_ _width_
(SEW).  By default, a vector register is viewed as being divided into
stem:[VLMAX = \frac{VLEN}{SEW}] standard elements (always an integer
power of 2).  The VLMAX derived from SEW is used to control the number
of iterations of standard stripmining loops.

[source]
----
  vsew[2:0] (standard element width) encoding

  vsew  SEW
  ---  ----
  000     8
  001    16
  010    32
  011    64
  100   128
  101   256
  110   512
  111  1024
----

NOTE: For example, a machine with stem:[VLEN=128] has the following
stem:[VLMAX] values for the following stem:[SEW] values:
(stem:[SEW=32b, VLMAX=4]); (stem:[SEW=16b, VLMAX=8]); (stem:[SEW=8b, VLMAX=16]).

=== Interaction of vectors and standard scalar floating-point code

The vector extension does not modify the behavior of standard scalar
floating-point instructions.  Standard scalar floating-point
instructions will operate on the lower FLEN bits of each vector
register, and will perform NaN-boxing on floating-point results that
are narrower than FLEN.

NOTE: Scalar floating-point loads and stores move bit patterns between
memory and registers can be used to load and store element 0 of a
vector registers with a wider immediate offset than the vector load
and store instructions.  Implementations using floating-point recoding
techniques might experience a performance penalty when using
floating-point loads and stores to move integer values.

== Vector Length register `vl`

The stem:[XLEN]-bit-wide read-only `vl` CSR can only be updated by the
`vsetvli` and `vsetvl` instructions.

The `vl` register holds an unsigned integer specifying the number of
elements to be updated by a vector instruction.  Elements in the
destination vector with indices stem:[\geq vl] are not updated during
execution of a vector instruction.  As a degenerate case, when `vl`=0,
no elements are updated in the destination vector.

== Maximum vector Length register `vlmax`

The XLEN-wide `vlmax` CSR is a read-only register whose value is
derived from the other state in the system.  The `vlmax` register
holds an unsigned integer representing the largest number of elements
that can be completed by a single vector instruction with the current
`vtype` setting.  The value in `vlmax`stem:[= \frac{VLEN}{SEW}].

== `vsetvli`/`vsetvl` instructions

----
 vsetvli rd, rs1, vtypei # rd = new vl, rs1 = AVL, vtypei = new vtype setting
 vsetvl  rd, rs1, rs2    # rd = new vl, rs1 = AVL, rs2 = new vtype value
----

The `vsetvli` instruction sets the `vtype`, `vl`, and `vlmax` CSRs
based on its arguments, and writes the new value of `vl` into `rd`.

The new `vtype` setting is encoded in the immediate field `vtypei` for
`vsetvli` and in the `rs2` register for `vsetvl`.

NOTE: The immediate argument `vtypei` can be a compressed form of the
full vtype setting, capturing the most common use cases.

The `vtype` setting must be supported by the implementation, and the
 `vsetvl{i}` instruction will raise an illegal instruction exception
 if the setting is not supported.

NOTE: Would simplify pipelines if `vtype` value errors were flagged at
use not write, but somehow need to catch errant code without requiring
full XLEN bits in `vtype` when only a few bits are actually needed.
Can specify WARL but that would hide errors.

The requested application vector length (AVL) is passed in `rs1` as an
unsigned integer.

The `vlmax` register is set to stem:[VLMAX] based on the new
stem:[SEW] in the `vtype` setting .

=== Constraints on setting `vl`

The resulting `vl` setting must satisfy the following constraints:

. `vl = AVL` if `AVL \<= VLMAX`
. `vl >= ceil(AVL / 2)` if `AVL < (2 * VLMAX)`
. `vl = VLMAX` if `AVL >= (2 * VLMAX)`
. Deterministic on any given implementation for same input AVL and `vtype` values
. These specific properties follow from the prior rules:
.. `vl = 0` if  `AVL = 0`
.. `vl > 0` if `AVL > 0`
.. `vl \<= VLMAX`
.. `vl \<= AVL`


[NOTE]
--
The `vl` setting rules are designed to be sufficiently strict to
preserve `vl` behavior across register spills and context swaps for
`AVL \<= VLMAX`, yet flexible enough to enable implementations to improve
vector lane utilization for `AVL > VLMAX`.

For example, this permits an implementation to set `vl = ceil(AVL / 2)`
for `VLMAX < AVL < 2*VLMAX` in order to evenly distribute work over the
last two iterations of a stripmine loop.
Requirement 2 ensures that the first stripmine iteration of reduction
loops uses the largest vector length of all iterations, even in the case
of `AVL < 2*VLMAX`.
This allows software to avoid needing to explicitly calculate a running
maximum of vector lengths.
--

=== `vsetvl` instruction

The `vsetvl` variant operates similary to `vsetvli` except that it
takes a `vtype` value from `rs2` and can be used for context restore,
and when `vtypei` can not hold desired setting.

NOTE: Several active complex types can be held in different `x`
registers and swapped in as needed using `vsetvl`.

== Vector element mapping to vector register state

To represent a variety of different width datatypes in the same
fixed-width vector registers, the mapping used between vector elements
and bytes in a vector register depends on the implementation's fixed
ELEN and the runtime SEW setting.

NOTE: Previous RISC-V vector proposals hid this mapping from software,
whereas this proposal has a specific mapping for all configurations,
which reduces implementation flexibilty but removes need for zeroing
on config changes.  Making the mapping explicit also has the advantage
of simplifying oblivious context save-restore code, as the code can
save the configuration in `vl`, `vlmax`, and `vtype`, then reset
`vtype` to a convenient value (e.g., vectors of ELEN) before saving
all vector register bits without needing to parse the configuration.
The reverse process will restore the state.

NOTE: This packing is designed to minimize datapath wiring complexity
when dealing with different bitwidth datatypes.

NOTE: Although implementations with different ELEN have different byte
packings, vector machine code can be written to produce the same
result on different implementations.

The following diagrams illustrate how different width elements are
packed into the bytes of a vector register depending on ELEN and the
current SEW setting.  The element index is shown placed at the
least-significant byte of the stored element.

[source]
----
 ELEN=32b

 Byte         3 2 1 0

 SEW=8b       3 2 1 0
 SEW=16b        1   0
 SEW=32b            0

 ELEN=64b

 Byte        7 6 5 4 3 2 1 0

 SEW=8b      7 6 5 4 3 2 1 0
 SEW=16b       3   2   1   0
 SEW=32b           1       0
 SEW=64b                   0


 ELEN=128b

 Byte        F E D C B A 9 8 7 6 5 4 3 2 1 0

 SEW=8b      F E D C B A 9 8 7 6 5 4 3 2 1 0
 SEW=16b       7   6   5   4   3   2   1   0
 SEW=32b           3       2       1       0
 SEW=64b                   1               0
 SEW=128b                                  0
----

When stem:[ VLEN > ELEN], the element numbering continues into the
following stem:[ELEN]-wide units.

----
 ELEN unit        3       2       1       0
 Byte          3 2 1 0 3 2 1 0 3 2 1 0 3 2 1 0

 SEW=8b        F E D C B A 9 8 7 6 5 4 3 2 1 0
 SEW=16b         7   6   5   4   3   2   1   0
 SEW=32b             3       2       1       0
----

Some vector instructions have some operands that are wider than the
current SEW setting.  In this case, a group of vector registers are
used to provide storage for the wider operands as shown below.

When an instruction has an operand twice as wide as SEW, e.g., a
vector load of 32-bit words when SEW=16b, then an even-odd pair of
vector registers are used to hold the double-width value as shown
below:

----
 Example 1: ELEN=32
 ELEN unit      3       2       1       0    
 Byte        3 2 1 0 3 2 1 0 3 2 1 0 3 2 1 0 
 SEW=16b       7   6   5   4   3   2   1   0   <=16-bit elements
 v2*n              6       4       2       0   32-bit elements
 v2*n+1            7       5       3       1 
----

The even-numbered vector register holds the even-numbered elements of
the double-width vector, while the odd-numbered vector register holds
the odd-numbered elements of the double-width vector.

NOTE: The pattern of storing elements in the pair of vector registers
is designed to simplify datapath alignment for mixed-width operations.

For quad-width operands that are stem:[4\times SEW] a group of four
aligned vector registers are used to hold the results:

----
 ELEN unit        3       2       1       0    
 Byte          3 2 1 0 3 2 1 0 3 2 1 0 3 2 1 0 

 SEW=8b        F E D C B A 9 8 7 6 5 4 3 2 1 0   8b elements
 v4*n                C       8       4       0   32b elements
 v4*n+1              D       9       5       1 
 v4*n+2              E       A       6       2 
 v4*n+3              F       B       7       3 
----

NOTE: A similar pattern is followed for octa-width operands
stem:[8\times SEW], though not clear that is necessary in mandatory
base.

=== Supporting Mixed-Width Operations at Full Throughput

Additional `setvli` variants are provided to modify SEW to handle
double-width elements in a loop.

[source]
----
setvl2ci rs1, vtypei  # sets vtypei, then sets vl according to AVL=ceil(rs1/2)
setvl2fi rs1, vtypei  # sets vtypei, then sets vl according to AVL=floor(rs1/2)

Example: Load 16-bit values, widen multiply to 32b, shift 32b result
right by 3, store 32b values.

loop:
    setvli t0, a0, VT_VINT16 # vtype = 16-bit integer vectors
    vlh v2, (a1)              # Get 16b vector
      slli t0, t0, 1
      add a1, a1, t0          # Bump pointer
    vmulw.vs v0, v2, v3       # 32b in <v0,v1> pair
    setvl2ci a0, VT_VINT32    # Ceil half length in 32b (can fuse with following)
    vsrl.vi v0, v0, 3        # Elements 0, 2, 4,...
    vsetvl2fi a0, VT_VINT32   # Floor half length in 32b (can fuse with following)
    vsrl.vi v1, v1, 3        # Elements 1, 3, 5,...
    vsetvli t0, a0, VT_VINT16 # Back to 16b
    vsw v0, (a2)              # Store vector of 32b <v0,v1> pair
      sub a0, a0, t0          # Decrement count
      slli t0, t0, 2
      add a2, a2, t0          # Bump pointer
      bnez a0, loop           # Any more?

Alternative loop only using wider elements:

loop:
    setvli t0, a0, VT_INT32 # Use only 32-bit elements
    vlh v0, (a1)            # Sign-extend 16b load values to 32b elements 
      sll t1, t0, 1
      add a1, a1, t1        # Bump pointer
    vmul.vs  v0, v0, v3     # 32b multiply result
    vsrl.vi  v0, v0, 3      # Shift elements
    vsw v0, (a2)            # Store vector of 32b results
      sll t1, t0, 2         
      add a2, a2, t1        # Bump pointer
      sub a0, a0, t0
      bnez a0, loop         # Any more?

The first loop is more complex but may have greater performance on
machines where 16b widening multiplies are faster than 32b integer
multiplies.  Also, the 16b vector load may run faster due to the
larger number of elements per iteration.
----

This technique allows for multiple wider operations to be performed
natively on each half of the wider vector.  Conversion operations
allow values to be copied into the double-width format, or back into
the single-width formate.

Other forms for quad (and octal) widths:

[source]
----
setvl4ci    #set correct length for vector v4*n
setvl4di    #set correct length for vector v4*n+1
setvl4ei    #set correct length for vector v4*n+2
setvl4fi    #set correct length for vector v4*n+3
----

== Vector instruction formats

Vector loads and stores move bit patterns between vector register
elements and memory.

Vector arithmetic instructions operate on values held in vector
register elements.

Vector instructions can have scalar or vector source operands and
produce scalar or vector results.  Scalar operands and results are
located in element 0 of a vector register.

== Vector masking

Masking is supported on almost all vector instructions producing
vectors, with the mask supplied by vector register `v0`.  The `LSB` of
each stem:[SEW]-wide element in `v0` is used as the mask, in either
true or complement form.  Element operations that are masked off do
not modify the destination vector register element and never generate
exceptions.  Instructions producing scalars are not maskable.

The type of masking is encoded in a two-bit `m[1:0]` field
(`inst[26:25]`) for all vector instructions.

[source]
----
m[1:0]

  00    vector, where v0[0] = 0
  01    vector, where v0[0] = 1
  10    scalar
  11    always true
----


== Vector Loads and Stores

The vector extension uses the floating-point load and store encoding
space.  The exisitng scalar floating-point loads and stores are used
for scalar loads and stores, and also for vector loads and stores.

=== Operation of Floating-Point Load/Store Instructions in Vector Extension

The standard FDQ floating-point extensions' loads and stores retain
their original meaning.

The standard floating-point loads (FLH, FLW, FLD, FLQ), read a single
value from memory and update the low stem:[FLEN] bits of the
destination vector register.  Floating-point types narrower than
stem:[FLEN] are NaN-boxed, setting upper bits to 1.  If stem:[VLEN >
FLEN], the upper bits of the vector register are unchanged by the
floating-point load.

The standard floating-point stores (FSH, FSW, FSD, FDQ) read the
appropriate number of bits from the least-significant bits of the
vector register and write these to memory.

The standard floating-point load and store instructions do not
interpret the bits that they move and so are unaffected by changes to
the `vrep` field in `vtype`.

=== Vector Load/Store Instruction Encoding

These are encoded within the floating-point load and store encoding space.

The vector loads and stores are encoded using the width values that
are not claimed by the standard floating-point loads and stores.  The
vector load store encodings use additional bits taken from the imm12
field of scalar loads and stores.

[source]
----
Width xv  Mem     Reg               uoffset5 to bytes scale
          Bits    Bits              (set by width[1:0])
 000  0  vl*8     vl*8      VxB     1
 000  1  vl*SEW   vl*SEW    VxE     1
 001  x    16     FLEN      FLH     N/A
 010  x    32     FLEN      FLW     N/A
 011  x    64     FLEN      FLD     N/A
 100  x   128     FLEN      FLQ     N/A
 101  0  vl*16    vl*16     VxH     2
 101  1  vl*2*SEW vl*2*SEW  VxE2    2
 110  0  vl*32    vl*32     VxW     4
 110  1  vl*4*SEW vl*4*SEW  VxE4    4
 111  0  vl*64    vl*64     VxD     8
 111  1  vl*8*SEW vl*8*SEW  VxE8    8

The one-bit xv field encodes fixed or variable element width, and is located in the low 12 bits of the immediate
----

A portion of the 12-bit immediate field is repurposed to provide
further vector instruction encoding, with bits[26:25] holding the mask
information.

Bits [31:27] hold a 5-bit unsigned offset that is added to the base
register during vector addressing.  The offset is scaled according to
the low two bits of the width[2:0] field (effective offset =
uoffset[4:0] * 2^width[1:0]^), such that for fixed-width elements the
offset is scaled by the element size.  For dynamic-width elements, the
offset is not affected by the `vtype` setting to avoid having a
dependency between address generation and dynamic `vtype` value.

[source]
----
  31 30 29 28 27 26 25 24 23 22 21 20  Loads
  31 30 29 28 27 26 25 11 10  9  8  7  Stores
       uoffset5  m1 m0       funct5       


funct5 encodes:
name bits encoding
 xv   [4]
       0 fixed element size
       1 variable element size

order [3]
       0 sequential stores
       1 unordered stores

       0 unsigned load
       1 signed load

mop [2:0]
   0 0 0 unit-stride             
   0 0 1 unit-stride speculative loads
   0 1 0 constant-stride         
   0 1 1 indexed
   1 0 0 reserved
   1 0 1 reserved
   1 1 0 reserved
   1 1 1 AMO?
----

Vector load/store instructions move bit patterns between vector
register elements and memory.

Vector load/store base registers and strides are taken from the GPR
`x` registers.

When `vrep` is set to integer, vector load instructions can optionally
sign- or zero-extend narrower memory values into wider vector register
element destinations.

When `vrep` is set to floating-point, then loads will NaN-box narrower
memory values into a wider register element, regardless of signed or
unsigned opcode.

Vector unit-stride, constant-stride, and indexed (scatter/gather)
load/store instructions are supported.

When the m[1:0] field is set to scalar, the vector load/store
instructions move a single value between element 0 of the vector
register and memory.

NOTE: Option to have zero-extend of vector load of a scalar value to
not NaN-box out to FLEN bits, and instead leave bits past size of
operand unaffected?

NOTE: Vector AMO instructions are TBD.

=== Vector load instructions assembler code

==== unit-stride instructions

[source,asm]
----
    # vd destination, rs1 base address, rs2=x0, vm is mask encoding

    # fixed-size element
    vlb    vd, offset(rs1), vm # 8b
    vlh    vd, offset(rs1), vm # 16b
    vlw    vd, offset(rs1), vm # 32b
    vld    vd, offset(rs1), vm # 64b
    vle    vd, offset(rs1), vm # SEW
    vle2   vd, offset(rs1), vm # 2*SEW
    vle4   vd, offset(rs1), vm # 4*SEW
    vle8   vd, offset(rs1), vm # 8*SEW

    # first fault versions
    vlbff    vd, offset(rs1), vm # 8b 
    vlhff    vd, offset(rs1), vm # 16b
    vlwff    vd, offset(rs1), vm # 32b
    vldff    vd, offset(rs1), vm # 64b
    vleff    vd, offset(rs1), vm # SEW
    vle2ff   vd, offset(rs1), vm # 2*SEW
    vle4ff   vd, offset(rs1), vm # 4*SEW
    vle8ff   vd, offset(rs1), vm # 8*SEW
----

NOTE: Could encode unit-stride as constant-stride with rs2=x0, but
this would add to decode complexity.

==== constant-stride instructions
[source,asm]
----
    # vd destination, rs1 base address, rs2 byte stride
    vlsb    vd, offset(rs1), rs2, vm # 8b 
    vlsh    vd, offset(rs1), rs2, vm # 16b
    vlsw    vd, offset(rs1), rs2, vm # 32b
    vlsd    vd, offset(rs1), rs2, vm # 64b
    vlse    vd, offset(rs1), rs2, vm  # SEW  
    vlse2   vd, offset(rs1), rs2, vm  # 2*SEW
    vlse4   vd, offset(rs1), rs2, vm  # 4*SEW
    vlse8   vd, offset(rs1), rs2, vm  # 8*SEW
----

The stride is interpreted as an integer representing a byte offset.

==== indexed (scatter-gather) instructions
[source,asm]
----
    # vd destination, rs1 base address, vs2 indices
    vlxb    vd, offset(rs1), vs2, vm  # 8b 
    vlxh    vd, offset(rs1), vs2, vm  # 16b
    vlxw    vd, offset(rs1), vs2, vm  # 32b
    vlxd    vd, offset(rs1), vs2, vm  # 64b
    vlxe    vd, offset(rs1), vs2, vm  # SEW  
    vlxe2   vd, offset(rs1), vs2, vm  # 2*SEW
    vlxe4   vd, offset(rs1), vs2, vm  # 4*SEW
    vlxe8   vd, offset(rs1), vs2, vm  # 8*SEW
----

Scatter/gather indices are treated as signed integers representing
byte offsets.  If stem:[SEW < XLEN], then indices are sign-extended to
stem:[XLEN] before adding to the base.  If stem:[SEW > XLEN], the
indices are taken from the least-significant stem:[XLEN] bits.

NOTE: stem:[SEW] has to be wide enough to hold the indices, which
could mandate larger stem:[SEW] than desired.  Ideally want to support
index vectors wider than stem:[SEW], by adding new vector indexed
loads and stores with double-width or greater vector indices.

=== Vector stores

Vector stores move data values as bits taken from the LSBs of the
source element.  If the store datatype is wider than stem:[SEW], then
multiple vector registers are used to supply the data as described
above.

==== unit-stride store instructions
[source,asm]
----
    vsb     vs3, offset(rs1), vm  # 8b 
    vsh     vs3, offset(rs1), vm  # 16b
    vsw     vs3, offset(rs1), vm  # 32b
    vsd     vs3, offset(rs1), vm  # 64b
    vse     vs3, offset(rs1), vm  # SEW  
    vse2    vs3, offset(rs1), vm  # 2*SEW
    vse4    vs3, offset(rs1), vm  # 4*SEW
    vse8    vs3, offset(rs1), vm  # 8*SEW
----

==== constant-stride store instructions
[source,asm]
----
    vssb    vs3, offset(rs1), rs2, vm  # 8b 
    vssh    vs3, offset(rs1), rs2, vm  # 16b
    vssw    vs3, offset(rs1), rs2, vm  # 32b
    vssd    vs3, offset(rs1), rs2, vm  # 64b
    vsse    vs3, offset(rs1), rs2, vm  # SEW  
    vsse2   vs3, offset(rs1), rs2, vm  # 2*SEW
    vsse4   vs3, offset(rs1), rs2, vm  # 4*SEW
    vsse8   vs3, offset(rs1), rs2, vm  # 8*SEW
----

==== indexed store (scatter) instructions (ordered by element)
[source,asm]
----
    vsxb    vs3, offset(rs1), vs2, vm  # 8b   
    vsxh    vs3, offset(rs1), vs2, vm  # 16b  
    vsxw    vs3, offset(rs1), vs2, vm  # 32b  
    vsxd    vs3, offset(rs1), vs2, vm  # 64b  
    vsxe    vs3, offset(rs1), vs2, vm  # SEW  
    vsxe2   vs3, offset(rs1), vs2, vm  # 2*SEW
    vsxe4   vs3, offset(rs1), vs2, vm  # 4*SEW
    vsxe8   vs3, offset(rs1), vs2, vm  # 8*SEW
----

==== unordered-indexed (scatter-gather) instructions
[source,asm]
----
    vsuxb   vs3, offset(rs1), vs2, vm  # 8b   
    vsuxh   vs3, offset(rs1), vs2, vm  # 16b  
    vsuxw   vs3, offset(rs1), vs2, vm  # 32b  
    vsuxd   vs3, offset(rs1), vs2, vm  # 64b  
    vsuxe   vs3, offset(rs1), vs2, vm  # SEW  
    vsuxe2  vs3, offset(rs1), vs2, vm  # 2*SEW
    vsuxe4  vs3, offset(rs1), vs2, vm  # 4*SEW
    vsuxe8  vs3, offset(rs1), vs2, vm  # 8*SEW
----

NOTE: Dropped reverse-ordered scatter for now, can use rgather to
reverse index order.

=== Vector memory model

Vector memory instructions appear to execute in program order on the
local hart.  Vector memory instructions follow RVWMO at the
instruction level, and element operations are ordered within the
instruction as if performed by an element-ordered sequence of
syntactically independent scalar instructions.  Vector indexed-ordered
stores write elements to memory in element order.

== Vector Arithmetic Instructions

The vector arithmetic instructions use a new major opcode (OP-V =
1010111~2~), but generally follow the encoding pattern of the scalar
floating-point instructions under the OP-FP opcode.

=== Vector-Vector and Vector-Scalar Arithmetic Instructions

Most vector arithmetic instructions have both vector-vector (`.vv`),
where both operands are vectors of elements, and vector-scalar
(`.vs`), where the second operand is a scalar taken from element 0 of
the second source vector register.  A few non-commutative operations
(such as reverse subtract) subtract are encoded with special opcodes.

=== Vector-Immediate Arithmetic Instructions

A few vector arithmetic instructions have vector-immediate forms
(`.vi`) where the second scalar argument is a 5-bit signed integer
encoded in `rs2` space.

----
vadd.vi vd, vrs1, 3
----

=== Widening Vector Arithmetic Instructions

A few vector arithmetic instructions are defined to be __widening__
operations where the destination elements are stem:[2\times SEW] wide
and are stored in an even-odd vector register pair.  The first operand
can be either single or double-width. These are generally written with
a `w` suffix on the opcode.

=== Mask encoding

All vector arithmetic instructions can be masked according to the
m[1:0] field.

[source]
----
mask encoding m[1:0] is held in inst[26:25]

m[1:0]
  00    vector, where v0[0] = 0
  01    vector, where v0[0] = 1
  10    scalar
  11    always true
----

=== Vector Arithmetic Operand encoding

[source]
----
rm[2:0] field is held in inst[14:12]

Encoding of operand pattern rm field for regular vector arithmetic
instructions.

rm2 rm1 rm0

0     0   0      Vector-vector   SEW =   SEW op SEW
0     0   1      Vector-vector                     
0     1   0      Vector-vector 2*SEW =   SEW op SEW
0     1   1      Vector-vector 2*SEW = 2*SEW op SEW

1     0   0      Vector-scalar   SEW =   SEW op s_SEW
1     0   1      Vector-imm      SEW =   SEW op simm[4:0]
1     1   0      Vector-scalar 2*SEW =   SEW op s_SEW
1     1   1      Vector-scalar 2*SEW = 2*SEW op s_SEW
----

Bit `rm[2]` selects between vector second source or scalar
second source.

Bit `rm[1]` selects whether the destination is twice the width of
stem:[SEW].

Bit `rm[0]` selects whether the first operand is one or two times the stem:[SEW] or whether the second operand is a 5-bit sign-extended immediate held in the `rs2` field.

The 5-bit immediate field is always treated as a signed integer and
sign-extended to stem:[SEW] bits, regardless of `vtype` setting.

NOTE: For floating-point representation, the 5-bit immediate can be
used to supply 0.0.

[source]
----
Assembly syntax pattern for vector arithmetic instructions

vop.vv  vd, vs1, vs2, vm    # vector-vector operation
vop.vs  vd, vs1, rs2, vm    # vector-scalar operation
vop.vi  vd, vs1, imm, vm    # vector-immediate operation

vopw.vv  vd, vs1, vs2, vm    # 2*SEW = SEW op SEW
vopw.vs  vd, vs1, rs2, vm    # 2*SEW = SEW op SEW

vopw.wv  vd, vs1, vs2, vm    # 2*SEW= 2*SEW op SEW
vopw.ws  vd, vs1, rs2, vm    # 2*SEW= 2*SEW op SEW
----

=== Legal Vector Arithmetic Instructions 

The following vector arithmetic instructions are provided

[source]
----
         .vv .vs .vi w.vv w.vs w.wv w.ws
VADD      x   x   x   x    x    x    x
VSUB      x   x   x   x    x    x    x

VAND      x   x   x   
VOR       x   x   x
VXOR      x   x   x   

VSLL      x   x   x   
VSRL      x   x   x   
VSRA      x   x   x   

VSEQ      x   x   x
VSNE      x   x   x
VSLT      x   x   x
VSLTU     x   x   x
VSLE      x   x   x
VSLEU     x   x   x

VMUL      x   x   x   x    x    x    x
VMULU     x   x   x   x    x    x    x
VMULSU    x   x   x   x    x    x    x
VMULH     x   x   x

VDIV      x   x   x
VDIVU     x   x   x
VREM      x   x   x
VREMU     x   x   x

VSQRT     x   x   x

VFSGNJ    x   x   x
VFSGNJN   x   x   x
VFSGNJX   x   x   x

VMIN      x   x   x
VMAX      x   x   x

VFCLASS   x   x   x

FMV*
FCVT*
----

=== Vector Comparison Instructions

The following compare instructions write `1` to the destination
register if the comparison evaluates to true and produces `0`
otherwise.

[NOTE] `VSNE` is not needed with complementing masks but sometimes
predicate results feed into things other than predicate inputs and so
`VSNE` can save an instruction.

[NOTE]: Need to revisit vector floating-point unordered compare
instructions.

[source,asm]
----
    vseq.vv    vd, vs1, vs2, vm
    vseq.vs    vd, vs1, rs2, vm
    vseq.vi    vd, vs1, imm, vm

    vsne.vv    vd, vs1, vs2, vm
    vsne.vs    vd, vs1, rs2, vm
    vsne.vi    vd, vs1, imm, vm

    ...
----

These conditionals effectively `AND` in the mask when producing
`0`/`1` in output, e.g,

[source,asm]
----
    # (a < b) && (b < c) in two instructions
    vslt.vv    v0, va, vb
    vslt.vv    v0, vb, vc, vm
----

The combination of VLT and VLTE can cover all cases, including
compares with scalars by complementing results:

[source]
----
v = s ,  ! (v = s) = (v != s)
v < s ,  ! (v < s) = (v >= s)
v <= s , ! (v <=s) = (v > s)
----

=== Vector Merge Instruction

The vector merge instruction combines two vectors based on the mask
field.

[source]
---- 
vmerge.vv vd, vs1, vs2, vm  # vd[i] = vm[i] ? vs2[i] : vs1[i] 
vmerge.vs vd, vs1, vs2, vm  # vd[i] = vm[i] ? vs2[0] : vs1[i] 
vmerge.vi vd, vs1, vs2, vm  # vd[i] = vm[i] ? imm    : vs1[i] 
----

The second operand is written where the mask is true.

NOTE: The `vmerge.vi` instruction can be used to initialize a vector
register with an immediate value, and the `vmerge.vs` instruction can
be used to __splat__ a scalar value into all elements of a vector.

=== Vector multiply/divide

These are all equivalent to scalar integer multiply/divides, and
operate on VSEW source and destination widths.

[source,asm]
----
    vmul.vv      vd, vs1, vs2, vm
    vmulh.vv     vd, vs1, vs2, vm
    vmulhsu.vv   vd, vs1, vs2, vm
    vmulhu.vv    vd, vs1, vs2, vm
    vdiv.vv      vd, vs1, vs2, vm
    vdivu.vv     vd, vs1, vs2, vm
    vrem.vv      vd, vs1, vs2, vm
    vremu.vv     vd, vs1, vs2, vm

Also have .vs and .vi variants
----

== Vector Narrowing instructions

A few instructions are provided to convert multi-width vectors into
single-width vectors.

[source]
----
 VSRN   vector shift right narrowing
 VSRAN  vector shift right arithmetic narrowing
 VCLIPN   vector clip after shift right narrowing
 VCLIPUN  vector clip unsigned after shift right narrowing

 vd[i] = clip(round(vs1[i] + rnd) >> vs2[i])
----

For VNSR/VNSRA, clip=nop, rnd = nop.

For VCLIPN, the value is treated as a signed integer and saturates if
result would overflow the destination.

For VCLIPUN, the value is treated as a signed integer and saturates if
result would overflow the destination.

For VCLIPN/VCLIPUN, the rounding mode is specified in the `fcsr` in a
new `vxrm[1:0]` field.  Rounding occurs around the LSB of the
destination.

[source]
----
 `vxrm[1:0]`
 Holds fixed-point rounding mode.

 00      rup   round-up (+0.5 LSB)
 01      rne   round to nearest-even
 10      trn   truncate
 11      jam   jam (OR bits into LSB)
----

The narrowing instructions used a different operand encoding in
`rm[2:0]`.

[source]
----
# vs1 = 2*SEW, 4*SEW

 rm2 rm1 rm0

 0     0   0      Vector-vector  SEW =  2*SEW op SEW
 0     0   1      Vector-vector                     
 0     1   0      Vector-vector  SEW =  4*SEW op SEW
 0     1   1      Vector-vector  

 1     0   0      Vector-scalar  SEW =  2*SEW op SEW
 1     0   1      Vector-imm     SEW =  2*SEW op imm
 1     1   0      Vector-scalar  SEW =  4*SEW op SEW
 1     1   1      Vector-imm     SEW =  4*SEW op imm
----

[source]
----
vclipn.vv vd, vs1, vs2, vm  # SEW = 2*SEW >> SEW
vclipn.vs vd, vs1, rs2, vm  # SEW = 2*SEW >> SEW
vclipn.vi vd, vs1, imm, vm  # SEW = 2*SEW >> imm

vclipn.wv vd, vs1, vs2, vm  # SEW = 4*SEW >> SEW  
vclipn.ws vd, vs1, rs2, vm  # SEW = 4*SEW >> SEW  
vclipn.wi vd, vs1, imm, vm  # SEW = 4*SEW >> imm  

vclipun.vv vd, vs1, vs2, vm  # SEW = 2*SEW >> SEW
vclipun.vs vd, vs1, rs2, vm  # SEW = 2*SEW >> SEW
vclipun.vi vd, vs1, imm, vm  # SEW = 2*SEW >> imm

vclipun.wv vd, vs1, vs2, vm  # SEW = 4*SEW >> SEW  
vclipun.ws vd, vs1, rs2, vm  # SEW = 4*SEW >> SEW  
vclipun.wi vd, vs1, imm, vm  # SEW = 4*SEW >> imm  

vsrln.vv vd, vs1, vs2, vm  # SEW = 2*SEW >> SEW
vsrln.vs vd, vs1, rs2, vm  # SEW = 2*SEW >> SEW
vsrln.vi vd, vs1, imm, vm  # SEW = 2*SEW >> imm

vsrln.wv vd, vs1, vs2, vm  # SEW = 4*SEW >> SEW  
vsrln.ws vd, vs1, rs2, vm  # SEW = 4*SEW >> SEW  
vsrln.wi vd, vs1, imm, vm  # SEW = 4*SEW >> imm  

vsran.vv vd, vs1, vs2, vm  # SEW = 2*SEW >> SEW
vsran.vs vd, vs1, rs2, vm  # SEW = 2*SEW >> SEW
vsran.vi vd, vs1, imm, vm  # SEW = 2*SEW >> imm

vsran.wv vd, vs1, vs2, vm  # SEW = 4*SEW >> SEW  
vsran.ws vd, vs1, rs2, vm  # SEW = 4*SEW >> SEW  
vsran.wi vd, vs1, imm, vm  # SEW = 4*SEW >> imm  
----


== Vector fused Multiply-Adds

The standard scalar floating-point fused multiply-adds occupy four
major opcodes.

There are two unused rounding modes that can be used to encode vector
fused multiply-adds, in both vector-vector and vector-scalar forms,
where the scalar is one input to the multiply.  When a scalar input to
the add is needed, this can be provided by splatting the value to a
vector.

[source]
----
rm2 rm1 rm0
 1   0   1      Vector-vector  vd = vs3 + vs1 * vs2
 1   1   0      Vector-scalar  vd = vs3 + vs1 * rs2
----

The FNMADD and FNMSUB variants are dropped in favor of widening vector
operations, which treat the add input and final result as
double-width.

[source]
----
VMADD     SEW = SEW + SEW*SEW
VMSUB     SEW = SEW + SEW*SEW
VMADDW  2*SEW = 2*SEW + SEW*SEW
VMSUBW  2*SEW = 2*SEW + SEW*SEW
----

=== Vector fused-multiply-add instructions

[source]
----
  vmadd.vvv vd, vs1, vs2, vs3, vm
  vmadd.vvs vd, vs1, rs2, vs3, vm
  vmaddw.vvv vd, vs1, vs2, vs3, vm
  vmaddw.vvs vd, vs1, rs2, vs3, vm
  vmsub.vvv vd, vs1, vs2, vs3, vm
  vmsub.vvs vd, vs1, rs2, vs3, vm
  vmsubw.vvv vd, vs1, vs2, vs3, vm
  vmsubw.vvs vd, vs1, rs2, vs3, vm
----

Additional fused multiply-add operations can be provided as
destructive operations in the regular vector arithmetic encoding
space.

=== Vector Reduction Operations

These instructions take a vector and scalar (vs2[0]) as input, and
produces a scalar result (vd[0]) that is a reduction over the source
scalar and vector.  Masked elements are ignored in the reduction.

[source,asm]
----
    vredsum.v   vd, vs1, vs2, vm #   SEW = SEW   + sum(SEW)
    vredsumw.v  vd, vs1, vs2, vm # 2*SEW = 2*SEW + sum(SEW)
    vredmax.v   vd, vs1, vs2, vm
    vredmaxu.v  vd, vs1, vs2, vm
    vredmin.v   vd, vs1, vs2, vm
    vredminu.v  vd, vs1, vs2, vm
    vredand.v   vd, vs1, vs2, vm 
    vredor.v    vd, vs1, vs2, vm
    vredxor.v   vd, vs1, vs2, vm
----

By default, when the operation is non-associative (e.g.,
floating-point addition) the reductions are specified to occur as if
done in sequential element order, but a user `fcsr` mode bit can
specify that unordered reductions are allowed.  In this case, the
reduction result must match some ordering of the individual sequential
operations.

A widening form of the sum reduction is provided that writes a
double-width reduction result.

== Vector Mask Operations

Several operations are provided to help operate on mask bits held in
the LSB of elements of a vector register.

=== `vmpopc` mask population count

[source]
----
    vmpopc rd, vs1, vm
----

The `vmpopc` instruction counts the number of elements of the first
`vl` elements of the vector source that have their low bit set,
excluding elements where the mask is false, and writes the result to a
GPR.

=== `vmfirst` find first set mask bit

[source]
----
    vmfirst rd, vs1, vm
----

The `vmfirst` instruction finds the lowest-numbered element of the
source vector that has its LSB set excluding elements where the mask
is false, and writes that element's index to a GPR.  If no element has
an LSB set, it writes -1 to the GPR.

== Vector Permutation Instructions

A range of permutation instructions are provided.

=== Vector Iota instruction

The VIOTA instruction writes to each element the index of the element.
If the index would overflow the destination, the least-significant
bits are retained.

[source]
----
 viota.v vd, vm   # Writes index to each element, vd[i] = i
----

=== Insert/Extract

The first form of insert/extract operations transfer a single value
between a GPR and one element of a vector register.  A second scalar
GPR operand gives the element index, treated as an unsigned integer.
If the index is out of range on a vector extract, then zero is
returned for the element value.  If the index is out of range (i.e.,
stem:[>VLMAX]) for a vector insert, the write is ignored.

[source]
----
vmv.x.v rd, vs1, rs2  # rd = vs1[rs2]
vmv.v.x vd, rs1, rs2  # vd[rs2] = rs1
----

The second form of insert/extract transfers a single value between
element 0 of one vector register and one indexed element of a second
vector register.

[source]
----
vmv.s.v vd, vs1, rs2 # vd[0] = vs1[rs2]
vmv.v.s vd, vs1, rs2 # vd[rs2] = vs1[0]
----

=== Slides

The slide instructions move elements up and down a vector.

[source]
----
 vslideup.vs vd, vs1, rs2, vm   # vd[i+rs2] = vs1[i]
 vslideup.vi vd, vs1, imm, vm   # vd[i+imm] = vs1[i]
----

For `vslideup`, the value in `vl` specifies the number of source
elements that are read.  The destination elements below the start
index are left undisturbed.  Destination elements past `vl` can be
written, but writes past the end of the destination vector are
ignored.

[source]
----
 vslidedown.vs vd, vs1, rs2, vm # vd[i] = vs1[i+rs2]
 vslidedown.vs vd, vs1, rs2, vm # vd[i] = vs1[i+imm]
----

For `vslidedown`, the value in `vl` specifies the number of
destination elements that are written.  Elements in the source vector
can be read past `vl`.  If a source vector index is out of range, zero
is returned for the element.

=== Register Gather

This instruction reads elements from a source vector at locations
given by a second source element index vector.  The values in the
index vector are treated as unsigned integers. The number of elements
to write to the destination register is given by `vl`.  The source
vector can be read at any index, stem:[index < VLMAX ].

[source]
----
vrgather.vv vd, vs1, vs2, vm # vd[i] = vs1[vs2[i]]
----

If the element indices are out of range ( stem:[ vs2[i\] \geq VLMAX] )
then zero is returned for the element value.

== Examples
=== Vector-vector add example

[source]
----
    # vector-vector add routine of 32-bit integers
    # void vvaddint32(size_t n, const int*x, const int*y, int*z)
    # { for (size_t i=0; i<n; i++) { z[i]=x[i]+y[i]; } }
    #
    # a0 = n, a1 = x, a2 = y, a3 = z
    # Non-vector instructions are indented
vvaddint32:
    vsetvli t0, a0, VT_VINT32 # Set vector length based on 32-bit vectors
    vlw v0, (a1)           # Get first vector
      sub a0, a0, t0         # Decrement number done
      slli t0, t0, 2         # Multiply number done by 4 bytes
      add a1, a1, t0         # Bump pointer
    vlw v1, (a2)           # Get second vector
      add a2, a2, t0         # Bump pointer
    vadd v2, v0, v1        # Sum vectors
    vsw v2, (a3)           # Store result
      add a3, a3, t0         # Bump pointer
      bnez a0, vvaddint32    # Loop back
      ret                    # Finished
----

=== Memcpy example

[source]
----
    # void *memcpy(void* dest, const void* src, size_t n)
    # a0=dest, a1=src, a2=n
    #
  memcpy:
      mv a3, a0 # Copy destination
  loop:
    vsetvli t0, a2, VT_VINT8  # Vectors of 8b
    vlb v0, (a1)              # Load bytes
      add a1, a1, t0            # Bump pointer
      sub a2, a2, t0            # Decrement count
    vsb v0, (a3)              # Store bytes
      add a3, a3, t0            # Bump pointer
      bnez a2, loop             # Any more?
      ret                       # Return
----

=== Conditional example

[source]
----
       (int16) z[i] = ((int8) x[i] < 5) ? (int16) a[i] : (int16) b[i];

Fixed 16b SEW:
loop:
    vsetvli t0, a0, VT_VINT16  # Use 16b elements.
    vlb v0, (a1)               # Get x[i], sign-extended to 16b
      sub a0, a0, t0           # Decrement element count
      add a1, a1, t0           # x[i] Bump pointer
    vslti v0, v0, 5            # Set mask in v0
      slli t0, t0, 1             # Multiply by 2 bytes
    vlh v1, (a2), v0.t         # z[i] = a[i] case
      add a2, a2, t0           # a[i] bump pointer
    vlh v1, (a3), v0.f         # z[i] = b[i] case
      add a3, a3, t0           # b[i] bump pointer
    vsh v1, (a4)               # Store z
      add a4, a4, t0           # b[i] bump pointer
      bnez a0, loop
----





== Increasing VLMAX through register grouping and `vlmul` field.

An additional field can be added to `vsetvl` configuration to increase
vector length when fewer architectural vector registers are needed by
grouping vector registers together.  The upper paired registers are
considered to add more ELEN units to the lowest-numbered vector
register.  Attempts to access the upper registers when they are
grouped raises an illegal-instruction execption.

[source]
----
 vlmul  #vregs  vnames   VLMAX
 00         32   v0-v31  VLEN/SEW
 01         16   v0-v15  2*VLEN/SEW
 10          8   v0-v7   4*VLEN/SEW
 11          4   v0-v3   8*VLEN/SEW
----

Register grouping structure:

[source]
----
vlmul
01      [v0,v16],[v1,v17],...,[v15,v31]
10      [v0,v8,v16,v24],[v1,v9,v17,v24],...,[v7,v15,v23,v31]
11      [v0,v4,v8,v12,v16,v20,v24],[v1,v5,v9,v13,v17,v21,v24],...,[v3,...,v31]
----

