= Vector extension
Proposal for "low-config" redesign 
:doctype: article
:encoding: utf-8
:lang: en
:toc: left
:numbered:
:stem: latexmath

== Implementation-defined constant parameters

These parameters are fixed for a given machine.  The ISA supports
writing code that is portable across machines with different values
for these parameters, under certain constraints.

The maximum size of a single vector element in bits, stem:[ELEN \geq
max(XLEN,FLEN) ]. Must be a power of 2.

The number of bits in a vector register, stem:[VBITS \geq ELEN].  Must
be a power of 2.

NOTE: Platform profiles may set further constraints on these
parameters, for example, requiring a minimm stem:[VBITS] or stem:[ELEN] value.

NOTE: Vector contexts cannot be migrated across vector units with
different VBITS and ELEN settings.

=== Vector Register File

There are 32 architectural vector registers, `v0`-`v31`.

Each vector register has a fixed stem:[VBITS] of state.

If the system has floating-point registers, the low stem:[FLEN] bits
of the vector registers overlay the floating-point registers.

If the system is Zfinx, the low stem:[XLEN] bits of the vector
registers overlay the integer registers.

NOTE: Zfinx ("F in X") is an option where floating-point instructions
take their arguments from the integer register file.  Overlaying
vectors on Zfinx would effectively replace the P extension.

==  Vector CSRs

The following CSRs are only modified via the `vsetvl` instruction, and
can not be written directly.

Read-only current standard element width, `vsew`.

Read-only vector length register, `vl`.

Read-only max vector length register, `vlmax`.

== Vector standard element width `vsew`

The value in `vsew` sets the dynamic _standard_ _element_ _width_
(SEW), encoded as follows:

[source]
----
  Standard element width (SEW) encoding

  vsew  bits
  000     8
  001    16
  010    32
  011    64
  100   128
  101   256
  110   512
  111  1024
----

The standard element width is the default operand width used for any
vector instruction that does not explicitly state operand widths.

By default, a vector register is viewed as being divided into stem:[VLMAX
= \frac{VBITS}{SEW}] standard elements (always an integer power of 2).

NOTE: For example, a machine with stem:[VBITS=128] has the following
stem:[VLMAX] values for the following stem:[SEW] values:
stem:[SEW=32b, VLMAX=4]; stem:[SEW=16b, VLMAX=8]; stem:[SEW=8b, VLMAX=16].

== Vector Length register `vl` and `vlmax`

Registers `vl` and `vlmax` are stem:[XLEN] bits wide, and are
read-only via CSR instructions.  They can only be updated by the
`vsetvli` and `vsetvl` instructions.

The `vl` register holds an unsigned integer specifying the number of
elements to be updated by a vector instruction.  Elements in the
destination vector with indices stem:[\geq vl] are not updated during
execution of a vector instruction.  As a degenerate case, when `vl`=0,
no elements are updated in the destination vector.

The `vlmax` register holds the largest number of elements that can be
completed by a single vector instruction.

== `vsetvli`/`vsetvl` instructions

----
 vsetvli rd, rs1, vsewi # rd = new vl, rs1 = AVL, vsewi = new SEW setting
 vsetvl  rd, rs1, rs2   # rd = new vl, rs1 = AVL, rs2 = vsew value
----

The `vsetvli` instruction sets the `vsew`, `vl`, and `vlmax` CSRs, and
writes the new value of `vl` into `rd`, based on the standard element
width in the immediate field `vsewi` and the requested application
vector length (AVL) in `rs1`.  AVL is treated as an unsigned integer.

`vsewi` is an immediate field in the `vsetvli` instruction and is used
to set the `vsew` CSR to a new SEW value.  The setting must be such
that stem:[SEW \leq ELEN], and raises an illegal instruction exception
on the `vsetvl` instruction if stem:[SEW > ELEN].

The `vlmax` register is set to stem:[VLMAX] using the new stem:[SEW]
setting.

The resulting `vl` setting must satisfy the following constraints:

. `vl = AVL` if `AVL \<= VLMAX`
. `vl >= ceil(AVL / 2)` if `AVL < (2 * VLMAX)`
. `vl = VLMAX` if `AVL >= (2 * VLMAX)`
. Deterministic for any given configuration and AVL
. These specific properties follow from the prior rules:
.. `vl = 0` if  `AVL = 0`
.. `vl > 0` if `AVL > 0`
.. `vl \<= VLMAX`
.. `vl \<= AVL`


[NOTE]
--
The `vl` setting rules are designed to be sufficiently strict to
preserve `vl` behavior across register spills and context swaps for
`AVL \<= VLMAX`, yet flexible enough to enable implementations to improve
vector lane utilization for `AVL > VLMAX`.

For example, this permits an implementation to set `vl = ceil(AVL / 2)`
for `VLMAX < AVL < 2*VLMAX` in order to evenly distribute work over the
last two iterations of a stripmine loop.
Requirement 2 ensures that the first stripmine iteration of reduction
loops uses the largest vector length of all iterations, even in the case
of `AVL < 2*VLMAX`.
This allows software to avoid needing to explicitly calculate a running
maximum of vector lengths.
--

=== `vsetvl` instruction

The `vsetvl` variant operates similary to `vsetvli` except that it
takes a `vsew` value from `rs2` and is primarily used for context
restore.

=== Increasing VLMAX through register grouping and `vlmul` field.

An additional field can be added to `vsetvl` configuration to increase
vector length when fewer architectural vector registers are needed by
grouping vector registers together.  The upper paired registers are
considered to add more ELEN units to the lowest-numbered vector
register.  Attempts to access the upper registers when they are
grouped raises an illegal-instruction execption.

[source]
----
 vlmul  #vregs  vnames   VLMAX
 00         32   v0-v31  VBITS/SEW
 01         16   v0-v15  2*VBITS/SEW
 10          8   v0-v7   4*VBITS/SEW
 11          4   v0-v3   8*VBITS/SEW
----

Register grouping structure:

[source]
----
vlmul
01      [v0,v16],[v1,v17],...,[v15,v31]
10      [v0,v8,v16,v24],[v1,v9,v17,v24],...,[v7,v15,v23,v31]
11      [v0,v4,v8,v12,v16,v20,v24],[v1,v5,v9,v13,v17,v21,v24],...,[v3,...,v31]
----


== Vector element mapping to vector register state

To represent a variety of different width datatypes in the same
fixed-width vector registers, the mapping used between vector elements
and bytes in a vector register depends on the implementation's fixed
ELEN and the runtime SEW setting.

NOTE: Previous RISC-V vector proposals hid this mapping from software,
whereas this proposal has a specific mapping for all configurations,
which reduces implementation flexibilty but removes need for zeroing
on config changes.  Making the mapping explicit also has the advantage
of simplifying oblivious context save-restore code, as the code can
save the configuration in `vl`, `vlmax`, and `vsew`, then reset SEW to
a convenient value (e.g., ELEN) before saving all vector register bits
without needing to parse the configuration.  The reverse process will
restore the state.

NOTE: This packing is designed to minimize datapath wiring complexity
when dealing with different bitwidth datatypes.

NOTE: Although implementations with different ELEN have different byte
packings, vector machine code can be written to produce the same
result on different implementations.

The following diagrams illustrate how different width elements are
packed into the bytes of a vector register depending on ELEN and the
current SEW setting.  The element index is shown placed at the
least-significant byte of the stored element.

[source]
----
 ELEN=32b

 Byte         3 2 1 0

 SEW=8b       3 1 2 0
 SEW=16b        1   0
 SEW=32b            0

 ELEN=64b

 Byte        7 6 5 4 3 2 1 0

 SEW=8b      7 3 5 1 6 2 4 0
 SEW=16b       3   1   2   0
 SEW=32b           1       0
 SEW=64b                   0


 ELEN=128b

 Byte        F E D C B A 9 8 7 6 5 4 3 2 1 0

 SEW=8b      F 7 D 3 B 5 9 1 E 6 C 2 A 4 8 0
 SEW=16b       7   3   5   1   6   2   4   0
 SEW=32b           3       1       2       0
 SEW=64b                   1               0
 SEW=128b                                  0
----

When stem:[ VBITS > ELEN], the element numbering continues into the
following stem:[ELEN]-wide units.

----
 ELEN unit      0       1       2       3
 Byte        3 2 1 0 3 2 1 0 3 2 1 0 3 2 1 0

 SEW=8b      3 1 2 0 7 5 6 4 B 9 A 8 F D E C
 SEW=16b       1   0   3   2   5   4   7   6
 SEW=32b           0       1       2       3

Alternatively, reading same pattern right to left.

 ELEN unit        3       2       1       0
 Byte          3 2 1 0 3 2 1 0 3 2 1 0 3 2 1 0

 SEW=8b        F D E C B 9 A 8 7 5 6 4 3 1 2 0
 SEW=16b         7   6   5   4   3   2   1   0
 SEW=32b             3       2       1       0
----

Some vector instructions operate on datatypes that are wider than the
current SEW setting.  In this case, a group of vector registers are
used to provide storage for the operands as shown below.

When an instruction has an operand twice as wide as SEW, e.g., a
vector load of 32-bit words when SEW=16b, then an even-odd pair of
vector registers are used to hold the value as shown:

----
 ELEN unit      0       1       2       3
 Byte        3 2 1 0 3 2 1 0 3 2 1 0 3 2 1 0
 SEW=16b       1   0   3   2   5   4   7   6      16-bit or narrower result pattern
                                                  32-bit result pattern
 v2*n              0       2       4       6
 v2*n+1            1       3       5       7
----

NOTE: The pattern of storing elements in the pair of vector registers
is designed to simplify datapath alignment for mixed-precision
operations.

For operands that are stem:[4\times SEW] a group of four aligned
vector registers are used to hold the result:

----
 ELEN unit        0       1       2       3
 Byte          3 2 1 0 3 2 1 0 3 2 1 0 3 2 1 0

 SEW=8b        3 1 2 0 7 5 6 4 B 9 A 8 F D E C   8b elements

                                                32b result pattern
 v4*n                0       4       8       C
 v4*n+1              1       5       9       D
 v4*n+2              2       6       A       E
 v4*n+3              3       7       B       F
----

NOTE: A similar pattern can be followed for stem:[8\times SEW] though
not clear that is necessary in base.

NOTE: This organization puts complexity into the memory-regfile path,
but reduces wiring in all regfile-ALU paths.  There are considerably
more regfile-ALU paths than memory-regfile paths, and the latter
already has to cope with various memory alignments.

=== Supporting >stem:[SEW] operations

Additional `setvli` variants are provided to modify sew to handle
double-wide elements in a loop.

[source]
----
setvl2ci rd, rs1, sewi  # sets sewi, then sets vl according to AVL=ceil(rs1/2)
setvl2fi rd, rs1, sewi  # sets sewi, then sets vl according to AVL=floor(rs1/2)

Example: Load 16-bit values, widen multiply to 32b, shift 32b result right by 3, store 32b values.

loop:
    setvli t0, a0, SEW16b   # SEW=16b
    vlw v2, (a1)            # Get vector
    sll t1, t0, 1
    add a1, a1, t1          # Bump pointer
    vmulw.vs v0, v2, v3     # 32b in <v0,v1> pair
    setvl2ci x0, a0, SEW32b # Ceil half length in 32b (can be fused with following)
    vsrli.vv v0, v0, 3      # Elements 0, 2, 4,...
    setvl2fi x0, a0, SEW32b # Floor half length in 32b (can be fused with following)
    vsril.vv v1, v1, 3      # Elements 1, 3, 5,...
    setvli t0, a0, SEW16b   # Back to 16b
    vsw v0, (a2)            # Store vector of 32b <v0,v1> pair
    sll t1, t0, 2
    add a2, a2, t1          # Bump pointer
    sub a0, a0, t0          # Decrement count
    bnez a0, loop
----

This technique allows for multiple wider operations to be performed
natively on each half of the wider vector.

Other forms for quad (and octal) widths:

[source]
----
setvl4ci    #set correct length for vector v4*n
setvl4di    #set correct length for vector v4*n+1
setvl4ei    #set correct length for vector v4*n+2
setvl4fi    #set correct length for vector v4*n+3
----

Need to use a convert instruction to copy predicates into wider
stem:[SEW] in matching pattern.

== Vector instruction formats

Vector loads and stores move bit patterns between vector register
elements and memory.

Vector arithmetic instructions operate on values held in vector
register elements.

Vector instructions can have scalar or vector source operands and
produce scalar or vector results.  Scalar operands and results are
located in element 0 of a vector register.

== Vector masking

Masking is supported on almost all vector instructions producing
vectors, with the mask supplied by vector register `v0`.  The `LSB` of
each stem:[SEW]-wide element in `v0` is used as the mask, in either
true or complement form.  Element operations that are masked off do
not modify the destination vector register element and never generate
exceptions.  Instructions producing scalars are not maskable.

The scalar/vector shape of the result and the type of masking are
encoded in a two-bit `m[1:0]` field (`inst[26:25]`) for most vector
instructions.

`m[1:0]` encoding of "masked-on" condition

----
00 scalar, always true
01 vector, always true
10 vector, where v0[0] = 0
11 vector, where v0[0] = 1
----

NOTE: An alternate encoding would split off the scalar opcodes,
reusing existing scalar opcodes, and use only a single bit to select
either "unmasked" or "masked by v0".

== Vector Load/Store Instructions

Vector load/store instructions move bit patterns between vector
register elements and memory.  Vector load instructions can optionally
sign- or zero-extend narrower memory values into wider vector register
element destinations.

Vector unit-stride, constant-stride, and indexed (scatter/gather)
load/store instructions are supported.

NOTE: Vector AMO instructions are not provided in the base vector
extension.

NOTE: Separate floating-point loads are not provided.  A consequence
is that narrower floating-point values are not automatically NaN-boxed
in a wider destination element.  A separate instruction could be
provided to 1-extend a narrower type to provide explicit NaN boxing if
necessary, but this is not proposed for base.

Load instructions include sign or zero-extend variants of each element
width, while store instructions encode only the bit width.

Vector loads of a scalar shape only load one element from memory at
the same memory address that would be used for vector shape element 0.
Vector masked loads of vector shapes must not generate architecturally
visible side-effects for masked-off elements.

Vector stores of a scalar shape store only one element to memory at
the same memory address that would be used for vector shape element 0.
Vector masked stores of vector shapes must not generate
architecturally visible side-effects for masked-off elements.

=== Vector memory model

Vector memory instructions appear to execute in program order on the
local hart.  Vector memory instructions follow RVWMO at the
instruction level, and element operations are ordered within the
instruction as if performed by an element-ordered sequence of
syntactically independent scalar instructions.  Vector indexed-ordered
stores write elements to memory in element order.

NOTE: Other possible vector indexed store instructions include
unordered and reverse-ordered.  Vector indexed-unordered stores write
elements to memory in arbitrary order within the vector
instruction. Vector indexed reverse-ordered writes elements in reverse
element order to help with vectorized memory alias disambiguation.

=== Vector load instructions

Vector load instructions encode bit width and sign/zero extension,
similar to the base scalar ISA.  Vector loads for a data type narrower
than stem:[SEW] are sign- or zero-extended to the configured vector
register element width.  Vector loads for a data type wider than
stem:[SEW] write multiple vector registers as described above.

==== unit-stride instructions
[source,asm]
----
    # vd destination, rs1 base address, vm is mask encoding
    vlb     vd, rs1, vm
    vlbu    vd, rs1, vm

    vlh     vd, rs1, vm
    vlhu    vd, rs1, vm

    vlw     vd, rs1, vm
    vlwu    vd, rs1, vm

    vld     vd, rs1, vm
----

[NOTE]
Speculative versions for unit-stride loads only in base?

[NOTE] Unit stride is encoded with `x0` in the `rs2` field of a
constant stride instruction

==== constant-stride instructions
[source,asm]
----
    # vd destination, rs1 base address, rs2 byte stride
    vlsb    vd, offset(rs1), rs2, vm
    vlsbu   vd, offset(rs1), rs2, vm

    vlsh    vd, offset(rs1), rs2, vm
    vlshu   vd, offset(rs1), rs2, vm

    vlsw    vd, offset(rs1), rs2, vm
    vlswu   vd, offset(rs1), rs2, vm

    vlsd    vd, offset(rs1), rs2, vm
----

The offset is encoded as an immediate (size TBD) that is then scaled
by the element size to give a byte offset.

The stride is interpreted as an integer representing a byte offset.

==== indexed (scatter-gather) instructions
[source,asm]
----
    # vd destination, rs1 base address, vs2 indices
    vlxb    vd, offset(rs1), vs2, vm
    vlxbu   vd, offset(rs1), vs2, vm

    vlxh    vd, offset(rs1), vs2, vm
    vlxhu   vd, offset(rs1), vs2, vm

    vlxw    vd, offset(rs1), vs2, vm
    vlxwu   vd, offset(rs1), vs2, vm

    vlxd    vd, offset(rs1), vs2, vm
----

The offset is encoded as an immediate (size TBD) that is then scaled
by the element size to give a byte offset.

Scatter/gather indices are treated as signed integers and are
sign-extended from the currently stem:[SEW] width to `XLEN`
representing byte offsets.

NOTE: Might ideally want to support index vectors wider than
stem:[SEW], but adds some complexity and probably no space in base.

=== Vector stores

Vector stores move data values as bits taken from the LSBs of the
source element.  If the store datatype is wider than stem:[SEW], then
multiple vector registers are used to supply the data as described
above.

==== unit-stride store instructions
[source,asm]
----
    vsb     vs3, rs1, vm
    vsh     vs3, rs1, vm
    vsw     vs3, rs1, vm
    vsd     vs3, rs1, vm
----

==== constant-stride store instructions
[source,asm]
----
    vssb    vs3, offset(rs1), rs2, vm
    vssh    vs3, offset(rs1), rs2, vm
    vssw    vs3, offset(rs1), rs2, vm
    vssd    vs3, offset(rs1), rs2, vm
----

==== indexed store (scatter) instructions
[source,asm]
----
    vsxb    vs3, offset(rs1), vs2, vm
    vsxh    vs3, offset(rs1), vs2, vm
    vsxw    vs3, offset(rs1), vs2, vm
    vsxd    vs3, offset(rs1), vs2, vm
----

==== indexed-unordered (scatter-gather) instructions (not in base spec)
[source,asm]
----
    vsxub   vs3, offset(rs1), vs2, vm
    vsxuh   vs3, offset(rs1), vs2, vm
    vsxuw   vs3, offset(rs1), vs2, vm
    vsxud   vs3, offset(rs1), vs2, vm
----

==== indexed-reverse-ordered (scatter-gather) instructions (not in base spec)

[source,asm]
----
    vsxrb   vs3, offset(rs1), vs2, vm
    vsxrh   vs3, offset(rs1), vs2, vm
    vsxrw   vs3, offset(rs1), vs2, vm
    vsxrd   vs3, offset(rs1), vs2, vm
----

==  Vector Arithmetic instructions, general formats

=== Unary operations

[source,asm]
----
   vop.s  vd, vs1        # Scalar operation
   vop.v  vd, vs1        # Unmasked vector operation
   vop.v  vd, vs1, v0.t  # Masked vector operation
   vop.v  vd, vs1, v0.f  # Complement masked vector operation
----

=== Binary register-register operations
[source,asm]
----
    vop.s   vd, vs1, vs2         # Scalar operation
    vop.vv  vd, vs1, vs2         # Vector-vector operation
    vop.vv  vd, vs1, vs2, v0.t   # Masked  vector-vector
    vop.vv  vd, vs1, vs2, v0.f
    vop.vs  vd, vs1, vs2         # Vector-scalar operation
    vop.vs  vd, vs1, vs2, v0.t   # Masked vector-scalar operation
    vop.vs  vd, vs1, vs2, v0.f   # Masked vector-scalar operation
----

=== Binary register-immediate operations
[source,asm]
----
    vop.si   vd,     vs1, imm       # Scalar operation with immediate
    vop.vi  vd,     vs1, imm       # Vector-scalar with scalar immediate.
    vop.vi  vd,     vs1, imm, v0.t
    vop.vi  vd,     vs1, imm, v0.f
----

=== Ternary register-register operations
[source,asm]
----
    vop.s    vd,  vs1, vs2, vs3  # Scalar operation
    vop.vvv  vd,  vs1, vs2, vs3  # Vector-vector-vector sources
    vop.vvv  vd,  vs1, vs2, vs3, v0.t # Masked
    vop.vvv  vd,  vs1, vs2, vs3, v0.f
    vop.vvs  vd,  vs1, vs2, vs3  # Vector-vector-scalar sources
    vop.vvs  vd,  vs1, vs2, vs3, v0.t # Masked
    vop.vvs  vd,  vs1, vs2, vs3, v0.f
----

== Vector integer arithmetic instructions

Vector integer arithmetic instructions use the currently configured
stem:[SEW] width of the source and destination vector registers.  All
vector integer arithmetic instructions can produce scalar or vector
shapes and can be masked.  A few integer instructions are
provided in a widening form, where one input is stem:[2\times
SEW]-wide and the other is stem:[SEW] wide, and the result is
stem:[2\times SEW] wide.

=== Vector Integer Add/Subtract

[source,asm]
----
    vadd.s  vd, vs1, vs2        # Scalar add
    vadd.vv vd, vs1, vs2, vm    # Vector-vector add
    vadd.vs vd, vs1, vs2, vm    # Vector-scalar add
    vadd.vi vd, vs1, imm, vm   # Vector-immediate add

    vsub.s vd, vs1, vs2          # Scalar sub
    vsub.vv vd, vs1, vs2, vm    # Vector-vector subtract
    vsub.vs vd, vs1, vs2, vm    # Vector-scalar subtract (v-s)
    vsubr.vs vd, vs1, vs2, vm   # Reverse vector-scalar subtract (s-v)
    vneg.v vd, vs1, vm         # Negate vector

    #Widening operations
    vadd2w.vv vd, vs1, vs2, vm  # vd,vs1 = 2*SEW, vs2 = SEW
    vsub2w.vv vd, vs1, vs2, vm  # vd,vs1 = 2*SEW, vs2 = SEW
----

=== Vector Shifts

Vector shifts use `log2(max(x, y))` lower bits of `vs2` for the shift value,
where `x` is the current configured element width of `vd`, and `y` is the
current configured element width of `vs1`.

[source,asm]
----
    vsl.s     vd, vs1, vs2
    vsl.vv    vd, vs1, vs2, vm
    vsl.vs    vd, vs1, vs2, vm  # vs1 << scalar
    vslr.vs    vd, vs1, vs2, vm # scalar << vs1
    vsl.vi   vd, vs1, imm, vm

    vsra.s     vd, vs1, vs2
    vsra.vv   vd, vs1, vs2, vm
    vsra.vs   vd, vs1, vs2, vm
    vsrar.vs   vd, vs1, vs2, vm
    vsra.vi  vd, vs1, imm, vm

    vsrl.s    vd, vs1, vs2
    vsrl.vv   vd, vs1, vs2, vm
    vsrl.vs   vd, vs1, vs2, vm
    vsrlr.vs   vd, vs1, vs2, vm
    vsrl.vi  vd, vs1, imm, vm
----

=== Vector Logical

[source,asm]
----
    vand.s   vd, vs1, vs2
    vand.vv  vd, vs1, vs2, vm
    vand.vs  vd, vs1, vs2, vm
    vand.vi  vd, vs1, imm, vm

    vor.s   vd, vs1, vs2
    vor.vv  vd, vs1, vs2, vm
    vor.vs  vd, vs1, vs2, vm
    vor.vi  vd, vs1, imm, vm

    vxor.s   vd, vs1, vs2
    vxor.vv  vd, vs1, vs2, vm
    vxor.vs  vd, vs1, vs2, vm
    vxor.vi  vd, vs1, imm, vm
----

=== Vector Integer Comparison

The following compare instructions write `1` to the destination register if the
comparison evaluates to true and produces `0` otherwise.
[NOTE]
`VSNE` is not needed with complementing masks but sometimes predicate results feed
into things other than predicate inputs and so `VSNE` can save an instruction.

[source,asm]
----
    vseq.vv    vd, vs1, vs2, vm
    vsne.vv    vd, vs1, vs2, vm
    vslt.vv    vd, vs1, vs2, vm
    vsltu.vv   vd, vs1, vs2, vm
    vsge.vv    vd, vs1, vs2, vm
    vsgeu.vv   vd, vs1, vs2, vm

Also need .s and .vs versions
----

These conditionals effectively `AND` in the mask when producing `0`/`1` in
output, e.g,

[source,asm]
----
    # (a < b) && (b < c) in two instructions
    vslt.vv    v0, va, vb
    vslt.vv    v0, vb, vc, vm
----

=== Vector integer multiply and divides

==== Full-width multiply/divides
These are all equivalent to scalar integer multiply/divides, and
operate on VSEW source and destination widths.

[source,asm]
----
    vmul.vv      vd, vs1, vs2, vm
    vmulh.vv     vd, vs1, vs2, vm
    vmulhsu.vv   vd, vs1, vs2, vm
    vmulhu.vv    vd, vs1, vs2, vm
    vdiv.vv      vd, vs1, vs2, vm
    vdivu.vv     vd, vs1, vs2, vm
    vrem.vv      vd, vs1, vs2, vm
    vremu.vv     vd, vs1, vs2, vm

Also need .s and .vs variants
----

==== Integer Multiply Add

The integer fused multiply-add is a destructive operation in order to save
encoding space. The two source operands `vs1`, `vs2` are multiplied
element-wise, and the result is accumulated into `vd`.

[source,asm]
----
    vmadd.vvv           vd, vs1, vs2, vm   # vd[i] += vs1[i]*vs2[i]
    vmadd.vvs           vd, vs1, vs2, vm   # vd[i] += vs1[i]*vs2[0]
    vmaddu.vvv          vd, vs1, vs2, vm
    vmaddu.vvs          vd, vs1, vs2, vm 
----

=== Integer Reduction Operations
These instructions take a vector shape as input and produce a scalar
shape.

[source,asm]
----
    vredsum.sv   vd, vs1
    vredmax.sv   vd, vs1
    vredmaxu.sv  vd, vs1
    vredmin.sv   vd, vs1
    vredminu.sv  vd, vs1
    vredand.sv   vd, vs1
    vredor.sv    vd, vs1
    vredxor.sv   vd, vs1
----

== Vector-vector add example

[source]
----
    # vector-vector add routine of 32-bit integers
    # void vvaddint32(size_t n, const int*x, const int*y, int*z)
    # { for (size_t i=0; i<n; i++) { z[i]=x[i]+y[i]; } }
    #
    # a0 = n, a1 = x, a2 = y, a3 = z
    # Non-vector instructions are indented
vvaddint32:
    vsetvli t0, a0, SEW32b # Set vector length based on 32-bit vectors
    vlw v0, (a1)           # Get first vector
      sub a0, a0, t0         # Decrement number done
      slli t0, t0, 2         # Multiply number done by 4 bytes
      add a1, a1, t0         # Bump pointer
    vlw v1, (a2)           # Get second vector
      add a2, a2, t0         # Bump pointer
    vadd v2, v0, v1        # Sum vectors
    vsw v2, (a3)           # Store result
      add a3, a3, t0         # Bump pointer
      bnez a0, vvaddint32    # Loop back
      ret                    # Finished
----
